# Day31

## Tag: BFS, Binary Tree

![Xnip2021-08-23_14-50-21](Algorithem/Xnip2021-08-23_14-50-21.jpg)



![Xnip2021-08-23_15-06-32](Algorithem/Xnip2021-08-23_15-06-32.jpg)

题意:

给你一颗二叉树，请你返回其层序遍历的结果(每层结果都保存为一个集合)





思路:

- 对二叉树层序遍历其实就是对二叉树进行广度优先搜索，所以我们使用广度优先即可
- 创建一个队列，每次都将当前层的节点添加到队列中，以下进入循环，条件为队列不为空
- 遍历当前队列所有元素(到当前为队列尾部为止，即只遍历所有的老元素)，记录在当前层集合中后删除
- 获取队列中每个元素对应的下一层节点，并将它们都添加到队列尾部
- 将记录老元素的当前层集合添加到结果集合中



实现(Java):

- 创建一个结果集合res，如果根结点为null，则直接返回这个空集合
- 创建一个队列用来记录当前层的节点
- 将根节点添加到队列中
- 如果队列不为空，则进行以下循环:
- 创建一个集合用来记录当前层的所有数值
- 获取队列当前的长度curLevelSize用于遍历
- 遍历curLevelSize次，确保只遍历到所有的老元素
- 将老元素从头开始删除，并用当前层集合记录下每个老元素对应的值
- 将每个老元素的左右子结点添加到队列中
- 最后将记录当前层的集合添加到结果集合中
- 循环后返回结果集合res



复杂度:

- 我们将所有的节点都遍历了一次，所以时间复杂度为O(n)
- 我们创建的集合记录了所有的节点，所以空间复杂度为O(n)

****









# Day32

## Tag: Binary Tree, Inorder, Preorder, Build

![Xnip2021-08-24_21-14-51](Algorithem/Xnip2021-08-24_21-14-51.jpg)



![Xnip2021-08-24_21-51-50](Algorithem/Xnip2021-08-24_21-51-50.jpg)



![Xnip2021-08-24_17-31-41](Algorithem/Xnip2021-08-24_17-31-41.jpg)

题意:

两个数组，一个是将通过二叉树前序遍历的顺序记录下的所有节点的值，另一个是将二叉树中序遍历记录下的所有节点的值，请你根据这两个数组将这颗二叉树重建，并返回它的根节点





思路:

- 首先需要明确前序遍历的顺序: 根节点 -> 左子树 -> 右子树
- 所以前序遍历数组preorder的第一个值一定为二叉树的根节点
- 对于中序遍历有: 左子树 -> 根节点 -> 右子树
- 那么，我们完全可以先通过前序遍历数组preorder找到根节点，之后在中序遍历数组inorder中定位根节点的位置
- 那么在中序遍历数组中，位于根节点之前的所有元素即为左子树的元素，后面则全是右子树的元素了
- 至此，我们成功的划分出了根节点、左子树、右子树的范围
- 在构建左右子树的时候又有如下规律:
- 在前序遍历数组中，左子树的根节点一定在根节点的后一位
- 在中序遍历数组中，左子树的左边界一定为0，左子树的右边界一定为根节点的左边一位(参照中序遍历的顺序)
- 在前序遍历数组中，右子树的根节点一定在左子树之后，所以我们需要构造出左子树的长度即:
- 根节点在中序遍历数组中的索引 + 根节点在前序遍历数组中的索引 - 左边界，最后 + 1即为左子树根节点在前序遍历数组中的位置
- 在中序遍历数组中，右子树的左边界在根节点的右边一个位置，右边界则不变
- 将以上步骤归为一个递归方法中，设置终止条件为: 子树左边界 > 子树右边界
- 最后返回构造的节点即可



实现(Java)

- 为了快速获取根节点在中序遍历数组中的索引位置，我们需要创建一个hash表，又因为原方法的方法签名不适合用作递归，为了在两个方法中都能使用，我们需要将该hash表设置为一个全局变量
- 为了在两个方法中都能获取前序遍历相关的元素，我们需要将前序遍历数组也设置为全局变量
- 在参数为两个数组的方法中，将前序遍历数组的引用传递给全局变量preorder，遍历一次中序遍历数组inorder，记录其中的值和对应的索引值于全局变量inorderRecorder中
- 运用方法重载，调用同名方法buildTree，其参数为: 根节点在前序遍历中的索引、根节点对应子树在中序遍历中左边界的索引、根节点对应子树在中序遍历中右边界的索引。这里我们先传入(0, 0, inorder.length - 1)
- 接下来是重载方法buildTree:
- 首先是终止条件: 如果左边界索引 > 右边界索引，则返回null
- 之后根据传入的根节点索引在前序遍历中，获取当前根节点的值，并以此构建一个节点
- 通过根节点的值在hash表"inorderRecorder"中获取根节点在中序遍历中的索引值(用来获取构建左右子树的相关索引)
- 按照上述的思路递归调用本方法，构建左右子树
- 最后返回构建的节点



复杂度:

- 我们遍历了所有的节点，并遍历了一次中序遍历数组用于存储信息到hash表中，所以时间复杂度为O(n)
- 我们创建了一个hash表来记录对应关系，为了构建答案我们也创建了一颗具有n个节点的树，至此我们消耗了2n的空间，最后递归调用的次数取决于树的深度d，所以空间复杂度为O(n)



拓展:

- 该题目同leetcode"105. 从前序与中序遍历序列构造二叉树"

****











# Day33

## Tag: Binary Tree, Right View, Recursive, BFS

![Xnip2021-08-25_11-40-36](Algorithem/Xnip2021-08-25_11-40-36.jpg)



![Xnip2021-08-25_11-56-13](Algorithem/Xnip2021-08-25_11-56-13.jpg)



![Xnip2021-08-25_12-06-23](Algorithem/Xnip2021-08-25_12-06-23.jpg)

题意:

给你一颗二叉树，请你找出其中所有只能从右边"看到"的节点值，并返回包含所有结果的集合





思路1:

- 这里有一个误区，从示例图片上看，好像我们只需要将所有的右节点对应的值都添加到集合中即可
- 如果真是这样的话一个循环就能解决，但事实上没这么简单: 万一一棵树某些层级没有右节点只有左节点呢？
- 那么所谓的能从右边"看到"的节点就变成了左节点了(没有了右节点的遮挡)
- 怎么转换为code呢？其实所谓能从右边"看到"的节点，其实就是每层中处于最右边或者说从左到右的最后一个节点
- 这样就很明确了，我们需要将每一层中的最后一个节点都添加到结果集合中，这样就需要我们按照每层的顺序遍历整颗树
- 按照每层的顺序？这不就是层序遍历吗，参考一下Algorithm Day31不就行了？轻松秒杀～





实现1(Java):

- 创建一个集合来记录所有的"右视角"节点
- 再创建一个队列来记录当前层的所有节点
- 先将根节点添加到队列中，之后便是BFS的过程:
- 进入循环，条件为队列不为空，首先获取队列当前的长度queueSize
- 循环queueSize次，确保删除所有的老元素，添加每个老元素对应的左右子结点
- 最后当索引值等于queueSize - 1时意味着遍历到了当前层的最后一个元素，将其对应的值添加到结果集合中即可
- 结果循环后返回结合集合



复杂度1:

- 我们遍历了一次所有的节点，所以时间复杂度为O(n)
- 最后的结果集合记录了所有的右视角节点，其最长为n(形如链表)，所以空间复杂度为O(n)







思路2:

- 通常我们遍历二叉树都会使用递归的方式来处理左右子结点
- 这里我们同样采用递归
- 在每层递归中都记录下当前层级的深度，将其与结果记录集合的长度相比较
- 由于每一层中只有一个"右视角"节点，所以如果深度与记录的集合长度相同
- 则说明当前层级还没有记录"右视角"节点，那么我们只需要保证第一个记录的节点为"右视角"节点即可
- 为了保证第一个节点为右视角节点，我们在递归左右子树时自然需要从右子结点开始，而每次递归后都需要将深度自增，代表该层级已经记录了右视角节点





实现2:

- 创建一个结果集合来记录所有右视角节点的值
- 通过一个递归方法来获取所有的右视角节点值
- 首先传入根节点，深度0，结果集合res
- 递归方法中，首先判断深度和结果集合长度的关系，如果相等则说明当前节点是当前层级第一个添加的节点，将当前节点对应的值添加到结果集合中
- 递增深度值，对左右子结点递归调用本方法



复杂度2:

- 我们遍历了所有的节点，所以时间复杂度为O(n)
- 结果集合记录了所有的右视角节点，而递归调用占用的栈空间取决于树的层级，所以空间复杂度为O(n)

****











# Day34

## Tag: Binary Tree, BFS, Level Traversal

![Xnip2021-08-26_15-21-56](Algorithem/Xnip2021-08-26_15-21-56.jpg)



![Xnip2021-08-26_15-27-22](Algorithem/Xnip2021-08-26_15-27-22.jpg)

题意:

给你一颗二叉树，请你按照锯齿形的顺序返回所有节点进行层序遍历的结果(锯齿顺序即奇数层从左到右，偶数层从右到左)



思路:

- 二叉树的层序遍历其实就是BFS，这一点我们再清楚不过，但问题是怎么处理每一层使其达到锯齿层序遍历的顺序呢？
- 因为锯齿的方向与层数相关，所以我们在记录每一层之前，需要先行判断层数的奇偶来确定添加的顺序，是奇数则添加到最后，否则就添加到最前面



实现(Java):

- 整体和层序遍历差不多，参考Algorithm Day31，只是多了一个深度depth而已
- 在添加每个节点前都需要判断深度depth的奇偶，按照奇偶添加元素到开头或者结尾



复杂度:

- 我们遍历了所有的节点，所以时间复杂度为O(n)
- 我们记录了所有的节点，所有空间复杂度为O(n)



拓展:

- 在记录每一层的节点值时，我们最好使用LinkedList即链表，如果使用List的话，每次将元素添加的开头的用时都为O(n)

****











# Day35

## Tag: Binary Tree, Iterate

![Xnip2021-08-27_14-09-05](Algorithem/Xnip2021-08-27_14-09-05.jpg)



![Xnip2021-08-27_14-52-03](Algorithem/Xnip2021-08-27_14-52-03.jpg)



![Xnip2021-08-27_14-52-16](Algorithem/Xnip2021-08-27_14-52-16.jpg)

题意:

给你一个二叉树，请你判断它是否对称







思路1:

- 想要解决该题目，就需要找到比较的方法规律
- 在题目示例中，我们可以发现：对于第二层的两个节点，左节点的右子结点等于右节点的左子结点，反之亦然
- 很明显，每一层都能运用这个规律，那么我们就可以使用递归了
- 终止条件为两节点的值不同，或者两个节点不都存在(只有一个节点存在自然不对称返回false，都不存在说明已经遍历完了整颗树或者root为null，返回true)



实现1(Java):

- 将根节点的左右子结点传入一个递归方法中
- 在该递归方法中，我们首先比较两节点是否都为null，是则返回true
- 之后判断是否有一个为null，有则自然不对称，返回false
- 最后判断两节点的值
- 返回值则递归调用本身，此时参数为leftNode.rigth, rightNode.left和leftNode.left, rightNode.right



复杂度1:

- 我们递归遍历了所有的节点，所以时间复杂度为O(n)
- 我们递归调用占用的栈空间取决于树的高度，所以空间复杂度为O(n)





思路2:

- 参照一中的方法，我们为何不使用BFS迭代呢？每次判断后都按照镜像顺序将子结点添加到队列中
- 每次取出前两个队列进行比较



实现2(Java):

- 创建一个队列，将节点值添加两次到该队列中
- 进入循环，每次取出前两个节点，如果取出的节点都为null，则直接跳过
- 如果其中一个为null或者两节点的值不同，则返回false
- 以上判读通过后按照对称的顺序将两节点的子节点添加到队列中
- 循环后返回true



复杂度2:

- 我们遍历了所有的节点，所以时间复杂度为O(n)
- 我们使用队列存储了所有的节点，所以空间复杂度为O(n)

****







# Day36

## Tag: Common Ancestor

![Xnip2021-08-28_21-28-32](Algorithem/Xnip2021-08-28_21-28-32.jpg)



![Xnip2021-08-28_21-24-20](Algorithem/Xnip2021-08-28_21-24-20.jpg)

题意:

给你一个二叉树和两个节点值，请你在该二叉树中找出这两个节点值的最近公共祖先节点



思路:

- 首先需要明确什么是祖先，对于一个节点k，如果它的子结点或者它本身等于节点q，则k是q的祖先节点
- 对应的如果q和p都等于或者被包含于k和k的子结点中，则k是q和p的公共祖先节点
- 那么最近公共祖先是什么呢？即在k是q和p公共祖先的前提下，k的左右子结点不为q和p的公共祖先
- 由于每个节点都可能是答案，所以我们需要把整颗树遍历一次
- 然而从定义可以看出，我们需要判断每个节点的左右子树是否存在目标节点，所以需要对一边进行遍历判断
- 这样的顺序便是先序遍历/DFS了
- 最后我们对左右子树的返回值进行判断，两个返回值自然有四种情况:
- 如果返回值都不为null，则说明目标值分属两侧，则返回root即可
- 如果都为null，则说明没有找到目标值，自然返回null
- 如果其中一个为null，则说明两个节点都在不为null的一边，则返回不为null的那边即可





实现(Java):

- 首先对根节点进行判断，如果其为null/或者等于其中一个目标节点，则返回root
- 之后递归调用本方法，判断左右子树是否存在目标节点
- 之后判断两边的返回值，如果都为null，则直接返回null
- 如果有一边为null，则返回另一边
- 否则返回root(目标节点分属两边)







复杂度:

- 我们遍历了所有的节点，所以时间复杂度为O(n)
- 我们递归调用占用的栈空间取决于树的高度，所以空间复杂度为O(n)

****







# Day37

## Tag: Binary Search Tree, Common Ancestor

![Xnip2021-08-29_12-55-09](Algorithem/Xnip2021-08-29_12-55-09.jpg)



![Xnip2021-08-29_13-14-47](Algorithem/Xnip2021-08-29_13-14-47.jpg)



![Xnip2021-08-29_13-23-48](Algorithem/Xnip2021-08-29_13-23-48.jpg)

题意:

给你一颗二叉搜索树，和两个目标节点，请你找出树中两个节点的最近公共祖先



思路1:

- 求最近公共祖先其实就是昨天的题目，所以我们直接照搬就能解决问题，这里不再赘述





思路2:

- 与昨天的题目不同的是，这里给出的是一颗二叉树搜索树，所以我们可以利用二叉搜索树的特性来解决问题
- 二叉搜索树的特性如下:
- 根节点的值大于左子树中所有的节点值，根节点的值小于右子树中所有的节点值
- 借用这个特性，我们从根节点开始，将节点值与两个目标值进行比较，如果大于两个目标值则更新根节点为左子树节点
- 如果小于则更新为右子树节点，直到更新的节点值不满足上述两个条件后，该节点则为我们需要的答案



实现2(Java):

- 从根节点出发，比较当前节点值与两个目标节点的值
- 如果当前节点值大于两个目标节点，则更新当前节点为其左子结点
- 如果小于则更新为当前节点的右子结点
- 如果上述都不满足，则直接返回当前节点



复杂度2:

- 最坏情况下，我们需要遍历所有的节点，所以时间复杂度为O(n)
- 我们没有创建任何变量，所以空间复杂度为O(1)

****





# Day38

## Tag: Binary Search Tree, Recursive Call

![Xnip2021-08-30_16-02-08](Algorithem/Xnip2021-08-30_16-02-08.jpg)



![Xnip2021-08-30_16-26-15](Algorithem/Xnip2021-08-30_16-26-15.jpg)



![Xnip2021-08-30_16-26-31](Algorithem/Xnip2021-08-30_16-26-31.jpg)

题意:

给你一颗二叉搜索树，和一个目标值，请你找出树中最接近该目标值的节点值





思路1:

- 既然是找最接近的，那自然需要我们逐个比较每个节点，又因为这是一棵二叉搜索树，所以我们可以利用它的性质
- 如果当前的节点值小于目标值，则更新节点为其右子结点，大于则更新为左子结点
- 相等则直接返回记录的最近值
- 在此之前需要判断并更新记录的最近值



实现1(Java):

- 我们需要创建一个变量来记录最近值，还需要一个BST来表示当前的节点
- 进入循环，条件为当前的节点不为null
- 如果当前的节点值比我们记录的最近值还要"靠近"目标值的话，则更新最近值
- 之后判断当前节点值与目标值的大小关系，更新为对应的子结点或者直接返回



复杂度1:

- 最坏时我们需要遍历所有的节点，所以时间复杂度为O(n)
- 我们创建的变量个数为常量级，所以空间复杂度为O(1)









思路2:

- 按照前一种方法，我们可以通过递归的方式来比较节点与目标值，并更新最近值
- 同方法1一样，但把更新当前节点的步骤换为返回递归调用左右子结点即可



复杂度2:

- 最坏时我们需要遍历所有的节点，所以时间复杂度为O(n)
- 递归调用的栈空间取决于树的高度，所以空间复杂度为O(1)

****





# Day39

## Tag: Binary Search Tree, Mid-order Traversal

![Xnip2021-08-31_14-12-04](Algorithem/Xnip2021-08-31_14-12-04.jpg)



![Xnip2021-08-31_14-45-11](Algorithem/Xnip2021-08-31_14-45-11.jpg)



![Xnip2021-08-31_15-03-10](Algorithem/Xnip2021-08-31_15-03-10.jpg)

题意:

给你一颗二叉树，请你判断它是否为一颗二叉搜索树



思路1:

- 根据二叉搜索树的定义可以看出:
- 左节点值 < 根节点 < 右节点值
- 这个顺序不刚好是中序遍历的顺序吗？
- 所以我们可以将所有的节点值通过中序遍历一次，并通过这个顺序判断所有的节点值是否严格单增
- 如果是单增则说明该二叉树为二叉搜索树



实现1(Java):

- 创建一个集合来记录中序遍历的节点值
- 将二叉树进行一次中序遍历，将所有的值都记录到该集合中
- 遍历该集合，比较两个相邻的值，如果不是单调递增的话，则直接返回false



复杂度1:

- 我们遍历了一次整颗树，又遍历了一次该集合，所以时间复杂度为O(n)
- 我们创建了一个集合来记录所有的节点值，我们递归调用的栈空间取决于树的高度，所以空间复杂度为O(n)





思路2:

- 再次强调二叉搜索树的特性:
- 每个节点的左节点值小于该节点，右节点则大于该节点
- 只要对每个节点都做出如上判断即可



实现2(Java):

- 将根节点传入一个递归方法中，该方法记录当前的节点和其上一个节点(其为左节点则记录比他大的值，为右则记录比他小的值)
- 其中如果有一个节点的值小于其对应的最小值或者大于其对应的最大值，则说明不符合二叉搜索树的规则，返回flase



复杂度2:

- 我们遍历了一次所有的节点，所以时间复杂度为O(n)
- 我们递归调用的栈空间为二叉树的高度，所以空间复杂度为O(n)

****











# Day40

## Tag: Binary Search Tree, Pre-order, In-order, Post-order

![Xnip2021-09-01_16-19-21](Algorithem/Xnip2021-09-01_16-19-21.jpg)



![Xnip2021-09-01_16-18-59](Algorithem/Xnip2021-09-01_16-18-59.jpg)

复杂度:

- 我们遍历了所有的节点，所以时间复杂度为O(n)
- 我们存储了遍历的结果，所以空间复杂度为O(n)



面试:

- 这仨都不会写，面二叉树就等着G吧

****









# Day41

## Tag: Binary Search Tree, Recursive Call

![Xnip2021-09-02_13-29-33](Algorithem/Xnip2021-09-02_13-29-33.jpg)



![Xnip2021-09-02_14-06-32](Algorithem/Xnip2021-09-02_14-06-32.jpg)



![Xnip2021-09-02_14-06-48](Algorithem/Xnip2021-09-02_14-06-48.jpg)



题意:

给你一个递增的数组，请你通过这个数组构建一个高度最小的二叉搜索树



思路1:

- 同样的，明确一个二叉搜索树的节点规律: 左节点 < 根节点 < 右节点
- 也就是说根节点为中间值，这不刚好就是这个数组中间位置的值吗？
- 所以我们先获取中间的索引值，再获取中间值，将其作为根节点即可
- 获取中间索引后，我们就可以将整个数组从中间索引位置划分为两个部分
- 前面为左子树，后面为右子树
- 左右范围内的数按照相同的方法可以再次进行划分



实现1(Java):

- 传递该数组和一个空节点，并传递该数组的起始和结束索引到一个递归方法中 
- 判断起始索引和结束索引的大小，越界则直接返回null
- 获取当前范围的中间索引位置，获取当前的中间值
- 判断当前根节点是否为null，不是则判断根节点值与当前中间值的大小关系，添加其到对应的左右子结点，否则直接将其作为根节点的值
- 之后递归调用本方法来构建左右子树
- 最后返回根节点即可



复杂度1:
- 我们通过中间索引遍历了数组中所有的值，所以时间复杂度为O(n)
- 我们递归调用的栈空间取决于构建出的树的深度，其与数组长度n有关，所以空间复杂度为O(n)






思路2:
- 同方法一一样，我们需要先找出中间值作为根节点值
- 不一样的是，既然我们已经分出了左右子树的范围，那为什么还要判断大小呢？直接按顺序构造左右子树不就好了？





实现2:
- 将实现1中的比较步骤去掉，不传入当前的根节点而是直接构造左右子结点即可





复杂度2:
- 我们将所有的值都遍历了一次，所以时间复杂度为O(n)
- 我们递归调用的栈空间与数组的长度相关，所以空间复杂度为O(n)

****















# Day42

## Tag: Binary Search Tree, Inorder Traverse

![Xnip2021-09-03_13-21-35](Algorithem/Xnip2021-09-03_13-21-35.jpg)



![Xnip2021-09-03_13-22-39](Algorithem/Xnip2021-09-03_13-22-39.jpg)

题意:

给你一颗二叉搜索树和一个数字k，请你返回其中第k大的数



思路1:

- 第k大也就是需要对这颗二叉树进行排序，而排序自然需要遍历这颗树
- 诶！对二叉搜索树中序遍历的结果不就是升序排列吗？
- 我们要找的数字就是结果中倒数第k个数呀！



实现1(Java):

- 创建一个列表inorderTraversalList来记录中序遍历的节点值
- 对二叉树进行中序遍历，并将所有的节点值记录到列表中
- 返回索引值为list.size() - k的值即为结果



复杂度1:

- 我们整颗树遍历了一次，所以时间复杂度为O(n)
- 我们创建了一个列表来存储所有的节点，所以空间复杂度为O(n)





思路2:

- 通过中序遍历，我们得到的是所有节点值升序排列的结果，如果我们将左右节点的递归顺序调换一下，不就能得到降序结果了吗

****













# Day43

## Tag: Binary Search Tree, Stack, 

![Xnip2021-09-04_13-46-13](Algorithem/Xnip2021-09-04_13-46-13.jpg)


![Xnip2021-09-04_14-49-31](Algorithem/Xnip2021-09-04_14-49-31.jpg)



![Xnip2021-09-04_14-45-33](Algorithem/Xnip2021-09-04_14-45-33.jpg)



![Xnip2021-09-04_14-46-17](Algorithem/Xnip2021-09-04_14-46-17.jpg)



![Xnip2021-09-04_14-46-31](Algorithem/Xnip2021-09-04_14-46-31.jpg)

题意:

给你一颗二叉搜索树前序遍历的结果数组/集合，请你通过它重建起该二叉搜索树





思路1:

- 对于前序遍历，无非分为根节点、左子树、右子树三个部分而已
- 根节点就是前序遍历的第一个数字，而对于二叉搜索树而言，右子树的根节点就是根节点后第一个大于它的数值
- 所以我们只需要从根节点之后遍历一次该前序遍历数组/集合，便能找到右子树的根节点了，继而将前序遍历数组/集合分为左右子树
- 对于左右子树的部分，我们使用同样的步骤可以再次进行划分，每次左右子树的左右边界都是(根节点索引 + 1, 右子树根节点索引 - 1)和(右子树根节点, 前序遍历数组/集合末尾索引)
- 所以子树的构造使用递归即可



实现1:

- 如果参数为数组，我们需要重新构造一个递归方法，传入前序遍历数组和起始结束索引，如果是集合则不用
- 如果左右大小改变则直接返回null，将参数中的数组/集合中的第一个元素作为根节点的值以构建根节点
- 遍历一次当前数组/集合来搜寻右子树的根节点值索引
- 找到后递归调用本方法，如果是数组则传入前序遍历数组和两子树的左右边界
- 如果是集合则直接返回subList的结果，subList的参数为左右子树的边界



复杂度1:

- 我们每次查找当前树的右子树根节点索引的总花费为n，而递归调用的花费也为n，所以时间复杂度为O(n^2)
- 我们递归调用的栈空间与节点数有关，我们重建了每个节点，所以空间复杂度为O(n)





思路2:

- 在方法一中，我们每次都通过顺序遍历的方式来查找右子树的根节点索引，能不能换一种高效的方法呢？
- 这里我们将顺序遍历改为二分法就能大幅缩短时间了



实现2:

- 将实现1中顺序遍历搜寻右子树根节点索引的步骤变为二分法即可，其余不变



复杂度2:

- 我们改为二分后，搜寻的花费变为log(n)，所以时间复杂度变为O(nlog(n))
- 空间复杂度不变，所以为O(n)









思路3:

- 能不能简化为O(n)呢？即只遍历一次？
- 这里我们可以借助栈
- 创建根节点后将其压入一个栈中
- 从根节点的下一个索引位置开始遍历，比较当前节点的值和栈顶元素的值
- 如果当前节点值大于栈顶元素，则将栈顶元素弹出，直到栈顶元素较大，或者栈为空(弹出了根节点)
- 记录下最后一个弹出的元素(最后一个弹出的元素为当前元素的父节点)，比较最后一个元素与当前元素的值，将当前元素添加为对应的左右节点
- 将当前元素入栈，使得它作为新的栈顶元素参与后续的比较



实现3:

- 创建一个栈，通过前序遍历的第一个元素创建根节点，并将其压入栈中
- 从根节点索引的后一个位置开始遍历前序遍历结果
- 比较当前节点值和栈顶元素值，如果大于且栈不为空则弹出栈顶的元素
- 将最后弹出的元素作为当前节点值的父节点，将当前节点设置为对应的左右子结点
- 将当前节点入栈，使其作为新的栈顶元素



复杂度3:

- 我们只遍历了一次该中序遍历数组/集合，所以时间复杂度为O(n)
- 我们创建了栈并创建了每个节点，所以空间复杂度为O(n)

****













# Day44

## Tag: Binary Search Tree, Construct

![Xnip2021-09-05_20-11-12](Algorithem/Xnip2021-09-05_20-11-12.jpg)



![Xnip2021-09-05_20-25-27](Algorithem/Xnip2021-09-05_20-25-27.jpg)

题意:

给你一个递增的数组，请你根据它创建一个二叉搜索树，且必须是高度平衡二叉树(左右子树的高度差不大于1)



思路:

- 虽然有高度平衡二叉树的限制，但我们其实只需要正常的构建左右子树就行了
- 根据二叉搜索树的性质，在数组居中位置的值刚好就是根节点的值，以此我们可以将数组划分为左右子树
- 将这两个范围内的数字重新作为新的数组范围，来构建左右子树即可



实现(Java):

- 另设一个递归方法，其参数为数组、左边界、右边界
- 将左右边界的中间位置作为当前的根节点索引，递归调用本身，传入新的左右边界来构建左右子树
- 最后连接根节点和左右子树即可



复杂度:

- 我们遍历了数组中所有的数值，所以时间复杂度为O(n)
- 我们递归调用的栈空间取决于构建的树的高度，我们构建时使用了二分的方式，所以空间复杂度为O(log(n))

****













# Day45

## Tag: Greedy, Array

![Xnip2021-09-06_08-03-00](Algorithem/Xnip2021-09-06_08-03-00.jpg)



![Xnip2021-09-06_08-09-34](Algorithem/Xnip2021-09-06_08-09-34.jpg)

题意:

给你一个数组，其中每个数都代表执行该查询需要的时间，请你通过合理的排序后计算出执行所有查询所需的最小等待时间，等待时间的计算规则如下:

如果数组排列为{1, 3, 5}，那么等待时间为: 0 + 1 + (1 + 3) = 5





思路:

- 这里很明显，我们只需要将最大值排在最后，其余位置的值按照升序排列就是了
- 每个时间间隔的总花费则为该间隔 * 其出现的次数，其中出现次数则为数组的长度 - 该间隔的次序
- 最后将每个间隔的花费累加起来即可



实现(Java):

- 首先需要将所有的值升序排列，然后遍历排列后的数组
- 取出当前索引位置的元素和其对应的索引值，通过数组长度 - 索引值 - 1即可获得该时间间隔需要计算的次数了
- 最后将所有的时间间隔都累加起来即可



复杂度:

- 我们将数组进行了一次排序，之后又将该数组遍历了一次，所以时间复杂度为O(nlog(n))
- 我们创建的变量为常量级，所以空间复杂度为O(1)

****









# Day46

## Tag: Greedy, Array

![Xnip2021-09-07_13-25-48](Algorithem/Xnip2021-09-07_13-25-48.jpg)



![Xnip2021-09-07_13-51-49](Algorithem/Xnip2021-09-07_13-51-49.jpg)

题意:

给你两列学生的身高，他们其中一列都穿红色衬衣，另一列穿蓝色衬衣，两列人数相同。请你判断一下在以下条件内，能否将这些学生正确地排列为两排确保正常拍照: 

1. 同色衬衣的学生必须处于同一排
2. 后一排学生的高度必须大于他前一排的学生





思路:

- 想要做好比较，那么就得先对两列学生进行排序，然后才能一一对比身高
- 如果其中一列的第一个学生比另一列高，那么这一列会作为第二排，后面的同学也必须都比另一列高才行
- 所以，我们通过第一个同学获取一个之后的"趋势"，之后依次比较后面的同学，如果都符合趋势则能够正确排列，否则不能



实现(Java)

- 先对两个输入的学生集合进行排序，之后比较两集合中第一个元素之间的大小关系，如果相等则直接返回false
- 用一个boolean值来记录趋势，从后一个位置开始比较两集合中的元素，如果有一对元素不符合趋势，则直接返回false
- 遍历后如果没问题则返回true



复杂度:

- 我们将两个集合进行了排序，花费为2nlog(n)，之后又遍历了一次集合，所以时间复杂度为O(nlog(n))
- 我们创建的变量个数为常量级，所以空间复杂度为O(1)

****







# Day47

## Tag: Greedy, Array

![Xnip2021-09-08_07-23-37](Algorithem/Xnip2021-09-08_07-23-37.jpg)



![Xnip2021-09-08_07-22-38](Algorithem/Xnip2021-09-08_07-22-38.jpg)

题意:

给你两组人的骑车速度数组，其中一组穿红色衬衣，另一组穿蓝色衬衣，两组人数相同，请你将两组组合到双人自行车上，保证每辆车上的两人衣服颜色不同，其中车的速度由骑车速度较快的人决定，第三个参数fastest为true则计算这些车的最大总速度，为false则计算最小总速度







思路:

- 可以明确的是，如果想要总速度最小，则将两组中速度最小的人安排在一起则车辆的速度也是较小值
- 想要总速度最大则让每组中速度最快的人去带另一组最慢的人，这样就能保证车辆速度始终是较大值
- 为了方便的获取两数组中的最小/最大值，我们需要将两数组先进行排序
- 之后根据情况组合即可



实现(Java):

- 为了方便的获取最大/最小值，我们先对两数组进行排序，并创建一个变量来记录总速度
- 遍历一次两数组，判断fastest，如果其为true，则将其中一个数组的最大值与另一个数组的最小值进行组合(末尾索引和起始索引)
- 反之则将两数组的最小值进行组合



复杂度:

- 我们对两数组进行了排序，所以花费为2nlog(n)，之后又将数组遍历了一次，所以时间复杂度为O(nlog(n))
- 我们创建的变量个数为常量，所以空间复杂度为O(1)

****















# Day48

## Tag: Greedy, Array, Hash

![Xnip2021-09-09_08-25-21](Algorithem/Xnip2021-09-09_08-25-21.jpg)



![Xnip2021-09-09_08-29-02](Algorithem/Xnip2021-09-09_08-29-02.jpg)

题意:

给你一个数字k，其代表工人的数量，再给你一个长度为2k的数字集合，每个数字代表任务所需的用时。每个工人都需要分配两个任务，工人都可以同时工作，请你通过合理的分配，使得所有人结束工作所需的用时最短，结果应该返回每个工人所分配的任务在数字集合中的索引值







思路:

- 将问题抽象一下，即将2k个数字分配为k组，使得每组的和最为相近
- 这里有一个规律: 比如数字1到100，如果两两组合，则将开头和结尾的数字相加，则可以得到50组数字，每组数字的和都为101
- 比较这个规律和我们所拥有的集合: 规律中总是将最小值与最大值进行配对
- 为了能够更方便的获取最大最小值，我们需要先对该数组进行排序，但结果需要的是每个任务在参数集合中的索引，所以我们不能在原数组上进行排序，否则索引值就被打乱了，因此我们需要创建一个新的数组用来排序
- 按照之前的规律，我们通过双指针来获取首尾的任务用时，再通过它们来获取在原集合中的索引值，看似没问题，但如果任务用时有重复的呢，返回的索引应该是哪个呢？一组获取后，另一组通过相同的任务用时获取索引时，怎么防止获取前面的重复索引呢？
- 为了解决这个问题，我们需要引入一个hash表
- 首先将原数组添加到hash表中，将任务用时和对应的索引集合进行映射，这样通过任务用时获取索引时会获取一个索引集合
- 每次从索引集合中获取一个索引后进行删除，就可以避免获取重复的索引了





实现(Java):

- 按照思路，我们需要将任务用时集合记录到一个hash映射表中，键值对为任务用时-索引集合(Integer-ArrayList<Integer>)
- 再创建一个新的集合sortedTasks，使其引用原集合后，再将该集合进行排序
- 遍历k次(只需要配对k个工人)
- 从开始位置获取sortedTasks中的元素，其作为第一个任务
- 通过这个任务在hash映射中获取其在原集合中的索引集合，从中获取一个并删除，即可获得第一个任务的在原集合中的索引
- 同样的方法，从末尾位置开始获取sortedTasks中的元素作为第二个任务，重复之前的步骤即可获取第二个任务在原集合中的索引
- 创建一个集合并添加获取的两个任务索引，将该集合记录到结果集合即可
- 最后返回结果集合即可





复杂度:

- 我们首先遍历了一次原集合来创建hash表，用时为n，之后又对其拷贝进行了排序，用时nlog(n)，最后遍历了k次，所以时间复杂度为O(nlog(n))
- 我们创建了一个hash表和原数组的一个拷贝，并记录了结果集合，所以空间复杂度为O(n)

****















# Day49

## Tag: Greedy, Array

![Xnip2021-09-10_08-52-39](Algorithem/Xnip2021-09-10_08-52-39.jpg)



![Xnip2021-09-10_09-03-01](Algorithem/Xnip2021-09-10_09-03-01.jpg)

题意:

给你两个数组，其中一个表示当前城市距离下一个城市的里程(最后一个数值代表从最后一个城市到第一个城市的里程数)，另一个表示每个城市中能够获取的汽油数，再给你一个mpg值，其表示每加仑汽油能行驶的里程数，且汽油总数一定足够行驶所有的城市。请你找出一个正确城市的索引值，使得从该处开始能够经过所有的城市并返回(开始的汽油数为0)







思路:

- 首先最容易想到的肯定是将所有的城市都作为起始城市进行计算，直到达成为止，但这样计算的时间复杂度为O(n^2)，所以并不可取
- 这里有一个规律: 我们从第一个城市开始出发，记录下每到达一个城市后我们的剩余汽油数/里程数，这个数值可能为负，但我们先记录
- 遍历一次后记录下剩余汽油数/里程数最小值对应的城市索引，便是我们的答案了
- 也就是说，从最难到达的城市开始，就能成功经过所有的城市了，这个结论可由图像得出



实现(Java):

- 初始化我们的答案为索引0，当前剩余里程为0(也可以用剩余油量，这里用剩余里程是为了避免小数运算)，最小剩余里程为0
- 从索引1开始遍历整个城市数组，通过mpg值、前一个城市获取的汽油量和两城市的距离更新当前剩余里程
- 如果当前剩余里程小于最小剩余里程，则更新最小剩余里程，并更新城市索引
- 最后返回城市索引即可



复杂度:

- 我们只将所有的城市遍历了一次，所以时间复杂度为O(n)
- 我们创建的变量个数都为常量级，所以空间复杂度为O(1)

****

















# Day50

## Tag: Prime, Math

![Xnip2021-09-11_11-06-11](Algorithem/Xnip2021-09-11_11-06-11.jpg)



![Xnip2021-09-11_11-04-50](Algorithem/Xnip2021-09-11_11-04-50.jpg)



![Xnip2021-09-11_11-05-12](Algorithem/Xnip2021-09-11_11-05-12.jpg)

****















# Day51

## Tag: Graph, DFS

![Xnip2021-09-12_13-56-53](Algorithem/Xnip2021-09-12_13-56-53.jpg)



![Xnip2021-09-12_13-55-16](Algorithem/Xnip2021-09-12_13-55-16.jpg)

题意:

给你一个节点类，该类有一个字符类型name字段/属性，和一个可选的node集合字段children，请你为该类编写一个方法，接受一个空集合为参数，将对象的所有节点name字段值以深度优先的顺序全部添加到这个空集合中





思路:

- 既然是作为类方法，那么我们直接就能调用本对象并访问其name字段了，所以我们直接将当前对象的name先行添加到这个空集合中即可
- 之后再根据当前对象获取它的children集合中的每个node对象，并递归调用该方法即可处理集合中的对象



复杂度:

- 我们将每个节点都遍历了一次，所以花费为n，n为所有的节点数，我们在每个节点上都进行了递归调用，所以又花费了e，e为图中的边数，所以时间复杂度为O(n + e)
- 我们记录了每个节点，所以空间复杂度为O(n)

****











# Day52

## Tag: Array, Graph

![Xnip2021-09-13_07-36-41](Algorithem/Xnip2021-09-13_07-36-41.jpg)



![Xnip2021-09-13_07-36-24](Algorithem/Xnip2021-09-13_07-36-24.jpg)

题意:

给你一个数组，其中每个数组元素都代表从该位置开始的跳跃值，如数组{2, 3, 4}，从第一个元素开始，可以跳转两个索引位置，所以可以从它这里跳转到元素4的位置。请你判断该数组是否能出现单循环(从该数组任意元素出发，在回到该元素位置时能将所有的元素都访问一次)

注: 如果跳转后的索引位置 < 0或者 >= array.length - 1，则会被包裹到另一边，如跳转后索引值为-1的话，则会跳转到该数组的最后一个位置







思路:

- 分析题意，我们能提取出单循环的两个条件: 能返回到起始位置，且将每个元素都访问了一次
- 那么我们只需要满足其中一个之后，再查看另一个是否满足即可



实现(Java):

- 这里我们选择先满足访问每个元素的情况，用一个变量来记录被访问的元素个数，另一个变量用来表示当前的索引位置
- 设立一个循环，条件为被访问的元素个数小于数组长度(即未访问所有的元素)
- 循环中递增记录个数的变量，同时更加当前的索引，将跳转值与当前索引相加后需要对其取余，并判断其值的正负，以保证其落在正确的索引范围内
- 退出循环后我们只需要判断起始索引和当前索引是否相等即可
- 为了防止某些元素被重复访问，索引值不动的情况，我们在循环內进行判断，即如果索引值变为了起始索引，但此时的被访问元素个数大于0且小于数组长度(即还没有访问所有的元素就回去了/重复访问)，则直接返回false



复杂度:

- 我们访问了n次其中的元素，所以时间复杂度为O(n)
- 我们创建的变量为常量级，所以空间复杂度为O(1)

****













# Day53

## Tag: BFS, Queue

![Xnip2021-09-14_07-20-18](Algorithem/Xnip2021-09-14_07-20-18.jpg)



![Xnip2021-09-14_07-29-38](Algorithem/Xnip2021-09-14_07-29-38.jpg)

题意:

给你一个Node类，请你为其编写一个bfs方法，该方法接受一个空集合，将所有的节点名称添加到该集合中后最终返回该集合





思路:

- bfs即广度优先搜索，其实在之前我们做二叉树的层序遍历时经常用到这个搜索方式，所以不再赘述了(见Algorithm Day31)



复杂度:

- 我们遍历了所有的节点，所以时间复杂度为O(n)
- 我们将所有的节点值都记录到了参数集合中，且我们创建的队列记录了每个子集合，所以空间复杂度为O(n + e)，e为图的边数
















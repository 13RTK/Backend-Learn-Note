# Day91

## Tag: Back Track, DFS

![Xnip2021-10-22_08-02-24](Algorithem/Xnip2021-10-22_08-02-24.jpg)



![Xnip2021-10-22_08-48-27](Algorithem/Xnip2021-10-22_08-48-27.jpg)



![Xnip2021-10-22_08-48-46](Algorithem/Xnip2021-10-22_08-48-46.jpg)

题意:

给你一个数字n，代表生成括号的对数，请你找出能生成的所有有效对数的组合







思路1:

- 由于有效的括号都是成对的，所以这些括号可以形成一颗全二叉树，那么我们对该二叉树进行深度遍历后就能获取全部的组合方式
- 遍历二叉树自然能使用dfs递归，一旦获取的括号数量等于2 * n，则添加该组合方式到集合中
- 其中使用两个变量来记录左右括号的数量
- 最后返回该集合即可



复杂度1:

- 我们遍历了一次该二叉树，所以时间复杂度为O(n)
- 我们递归调用的栈空间取决于二叉树的高度，所以空间复杂度为O(log(n))







思路2:

- 使用回溯的方法，首先判断左括号的数量与n比较，如果小于则添加左括号
- 之后判断右括号是否小于左括号的数量(确保括号成对)，小于则添加右括号
- 一旦当前排列的长度等于2 * n，则添加当前排列并回溯
- 回溯后删除最后一个括号，从而获取另外的排列



复杂度2:

- 与卡特兰数有关，时间复杂度为O(4^n / √n)
- 我们递归调用的栈空间共2n层，所以空间复杂度为O(n)

****















# Day92

## Tag: Dynamic Programming, Array, Minus

![Xnip2021-10-24_16-01-49](Algorithem/Xnip2021-10-24_16-01-49.jpg)



![Xnip2021-10-24_16-09-19](Algorithem/Xnip2021-10-24_16-09-19.jpg)

题意:

给你一个数组，请你计算出其中乘积最大的连续子数组





思路:

- 因为是连续的子数组，所以不能简单的通过比较当前值和当前值与前一位置记录值的乘积来获取当前范围内的最大乘积(其只适用于不连续的情况)
- 其中需要注意的是负数，如果我只记录最大值，那么该值乘以一个负数就会成为最小值，反之之前的最小值负数乘以负数则会成为最大值
- 所以我们需要同时记录当前的最大和最小值，一旦原数组当前位置的值为负数，则会交换最大最小值的位置
- 最后需要考虑0，我们只需要在更新最大最小值时使用如下formula即可:
- current max = max(current max, current max * current num)
- current min = min(current mix, current mix * current num)
- 更新的同时记录最大值，最后返回最大值即可



复杂度:

- 我们遍历了一次原数组，所以时间复杂度为O(n)
- 我们创建的变量个数为常量级，所以空间复杂度为O(1)


















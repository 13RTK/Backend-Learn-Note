# Day91

## Tag: Back Track, DFS

![Xnip2021-10-22_08-02-24](Algorithem/Xnip2021-10-22_08-02-24.jpg)



![Xnip2021-10-22_08-48-27](Algorithem/Xnip2021-10-22_08-48-27.jpg)



![Xnip2021-10-22_08-48-46](Algorithem/Xnip2021-10-22_08-48-46.jpg)

题意:

给你一个数字n，代表生成括号的对数，请你找出能生成的所有有效对数的组合







思路1:

- 由于有效的括号都是成对的，所以这些括号可以形成一颗全二叉树，那么我们对该二叉树进行深度遍历后就能获取全部的组合方式
- 遍历二叉树自然能使用dfs递归，一旦获取的括号数量等于2 * n，则添加该组合方式到集合中
- 其中使用两个变量来记录左右括号的数量
- 最后返回该集合即可



复杂度1:

- 我们遍历了一次该二叉树，所以时间复杂度为O(n)
- 我们递归调用的栈空间取决于二叉树的高度，所以空间复杂度为O(log(n))







思路2:

- 使用回溯的方法，首先判断左括号的数量与n比较，如果小于则添加左括号
- 之后判断右括号是否小于左括号的数量(确保括号成对)，小于则添加右括号
- 一旦当前排列的长度等于2 * n，则添加当前排列并回溯
- 回溯后删除最后一个括号，从而获取另外的排列



复杂度2:

- 与卡特兰数有关，时间复杂度为O(4^n / √n)
- 我们递归调用的栈空间共2n层，所以空间复杂度为O(n)

****















# Day92

## Tag: Dynamic Programming, Array, Minus

![Xnip2021-10-24_16-01-49](Algorithem/Xnip2021-10-24_16-01-49.jpg)



![Xnip2021-10-24_16-09-19](Algorithem/Xnip2021-10-24_16-09-19.jpg)

题意:

给你一个数组，请你计算出其中乘积最大的连续子数组





思路:

- 因为是连续的子数组，所以不能简单的通过比较当前值和当前值与前一位置记录值的乘积来获取当前范围内的最大乘积(其只适用于不连续的情况)
- 其中需要注意的是负数，如果我只记录最大值，那么该值乘以一个负数就会成为最小值，反之之前的最小值负数乘以负数则会成为最大值
- 所以我们需要同时记录当前的最大和最小值，一旦原数组当前位置的值为负数，则会交换最大最小值的位置
- 最后需要考虑0，我们只需要在更新最大最小值时使用如下formula即可:
- current max = max(current max, current max * current num)
- current min = min(current mix, current mix * current num)
- 更新的同时记录最大值，最后返回最大值即可



复杂度:

- 我们遍历了一次原数组，所以时间复杂度为O(n)
- 我们创建的变量个数为常量级，所以空间复杂度为O(1)

****



















# Day93

## Tag: String, DP

![Xnip2021-10-25_07-33-29](Algorithem/Xnip2021-10-25_07-33-29.jpg)



![Xnip2021-10-25_07-56-08](Algorithem/Xnip2021-10-25_07-56-08.jpg)



![Xnip2021-10-25_07-59-10](Algorithem/Xnip2021-10-25_07-59-10.jpg)

题意:

给你一个字符串和一个字符串集合，请你判断该字符串被拆分后能否完全匹配字符串集合中的元素(集合中的元素不限使用次数)





思路1:

- 从空字符开始，我们判断该字符串能够被拆分成字符串集合中的元素，并创建对应的数组来记录每个长度下字符串的匹配结果
- 遍历一次原字符串，每次循环又从0位置开始，在前面范围的字符能被匹配的前提下判断当前位置的子字串能否被匹配
- 能则将当前位置的记录数组设为true，并跳出当前子循环



复杂度1:

- 我们遍历了一次输入字符串，每次循环又从0位置开始取子字符串，所以时间复杂度为O(n^2)
- 我们创建了一个记录数组，所以空间复杂度为O(n)





思路2:

- 在思路1中，每次子循环我们都需要从0位置开始，所以时间复杂度为O(n^2)
- 但其实当我们每次取的子字符串与字典集合匹配时，对应的子字符串长度总是小于等于字段集合中的最长元素
- 所以我们将子循环进行一些修改，将循环条件限制为子字符串长度 ≤ 字典集合中最长元素即可



复杂度2:

- 由于修改了子循环条件，所以时间复杂度为O(n * maxLen)
- 我们创建了一个记录数组，所以空间复杂度为O(n)










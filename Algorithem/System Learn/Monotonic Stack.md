# 一、每日温度

![Xnip2022-05-14_09-10-29](Monotonic Stack/Xnip2022-05-14_09-10-29.jpg)



![Xnip2022-05-14_09-27-53](Monotonic Stack/Xnip2022-05-14_09-27-53.jpg)

题意:

给你一个数组，其代表每天的温度，请你返回一个数组，其中每个元素代表从该天开始，经历多少天后才有更高的温度，如果没有则设置为0





思路:

- 最容易想到的方法就是为每个位置的元素遍历一次原数组，这样做的时间复杂度为O(n ^ 2)
- 想要将用时变为线性复杂度，则需要使用单调栈
- 所谓单调栈即栈中的元素是单调的，要么单调递增，要么单调递减，而顺序则可以是从栈顶到栈底，也可以反过来
- 单调栈恰恰就是用来解决这种求元素左边或者右边第一个比它大或者小的元素的问题
- 在该题目中，如果之后没有出现温度上升，则将当前元素设置为0，也就是说，如果之后的温度都没有变高，则不用做处理，而体现在单调栈中则是入栈
- 然而一旦之后有温度升高，则需要记录下这个升高的温度对应的日期和之前比他低的基准日期的差值，体现在栈中则是从栈顶弹出所有比它小的元素，并将栈顶元素对应的结果数设置为两天的日期差值，重复该步骤直到栈顶元素不比当前元素小为止
- 但问题是，如果我们在栈中直接存放的是对应的温度的话，我们怎么知道这个元素对应哪一个天呢，毕竟有出栈操作，所以不可能一一对应
- 其实我们只需要存放对应气温在原数组中的索引值即可，这样就能根据索引值知道对应的日期了，而日期差值也可以通过当前日期值对应索引 - 栈顶索引获取





复杂度:

- 我们只遍历了一次输入数组，所以时间复杂度为O(n)
- 我们创建了一个栈来存储单调的气温索引，所以空间复杂度为O(n)

<hr>











# 二、下一个更大元素1

![Xnip2022-05-15_09-54-04](Monotonic Stack/Xnip2022-05-15_09-54-04.jpg)



![Xnip2022-05-15_09-53-40](Monotonic Stack/Xnip2022-05-15_09-53-40.jpg)

题意:
给你两个数组，请你在第二个数组中找出与第一个数组相等的元素，并记录这些相等元素在第二个数组中所处位置的右边遇到的第一个比它大的元素





题意:

- 有了昨天的经验，很明显这道题目也需要使用单调栈解决
- 因为是获取右边第一个更大元素，所以和昨天一样，我们仍然需要维护一个从栈顶到栈底递增的栈，且依然记录的是索引(遇到一个更大元素时进行处理)
- 但这里和昨天不同的是，我们需要找的元素在第二个数组中，而基准元素在第一个数组中，所以我们需要进行转换
- 即在栈中存放第二个数组的索引，并遍历第二数组
- 如果出现当前元素大于栈顶索引对应元素的情况，则查看栈顶索引对应元素是否也存在于第一个数组中，如果有则记录当前这个大于栈顶的元素
- 每轮遍历后都将当前索引压入栈
- 所以我们现在需要快速通过第二数组元素查询其是否存在于第一个数组中，并且为了更新结果数组，我们还得能够快速获取该元素在第一个数组中对应的索引，所以这里我们可以使用一个Map，将一个数组中的元素和索引对应起来即可



复杂度:

- 我们遍历了两个数组中的元素，所以时间复杂度为O(n + m)
- 我们创建了一个Map来记录第一个数组中的元素和索引的关系，所以空间复杂度为O(n)














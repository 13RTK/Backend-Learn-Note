# 一、分发饼干

![Xnip2022-03-07_07-10-12](Greedy/Xnip2022-03-07_07-10-12.jpg)



![Xnip2022-03-07_07-16-42](Greedy/Xnip2022-03-07_07-16-42.jpg)

题意:

给你两个数组，其中一个数组中每个元素代表能满足一个孩子需要的饼干数量，另一个数组中的每个元素代表每个饼干的大小，请你尽可能多的喂饱孩子并返回满足的孩子数量





思路:

- 首先需要认识到，我们需要的是该题目的全局最优解，而贪心的思路就是将求全局最优解分解为局部最优解
- 贪心的问题就是怎样才能证明求局部最优解最终能解决全局最优解，其实贪心和动态规划一样没有固定套路，证明其有效的方法就是尝试举反例
- 在这里，我们局部最优解为先将大饼干分配给胃口大的孩子，尝试举反例后发现可行，所以能够得到全局最优



复杂度:

- 我们对两个数组进行了排序，所以时间复杂度为O(nlog(n) + mlog(m))
- 为了两个排序，我们需要一定的空间，所以空间复杂度为O(log(n) + log(m))

<hr>











# 二、摆动序列

![Xnip2022-03-08_07-10-21](Greedy/Xnip2022-03-08_07-10-21.jpg)



![Xnip2022-03-08_07-22-26](Greedy/Xnip2022-03-08_07-22-26.jpg)



![Xnip2022-03-08_07-25-44](Greedy/Xnip2022-03-08_07-25-44.jpg)

题意:

给你一个数组，请你计算出其中最长的摆动序列的长度



思路:

- 首先，摆动序列的条件为中间值在"山顶"或者"山谷"，在山脊部分的节点则不能统计在内
- 所以我们要做的就是判断当前节点前后的差值是否符合一个山顶或者山谷的条件，在code里体现在这一语句:if (curDiff > 0 && preDiff <= 0 || curDiff < 0 && preDiff >= 0)
- 有了方法后，我们只需要遍历该数组即可



复杂度:

- 我们遍历了一个输入数组，所以时间复杂度为O(n)
- 我们创建的变量个数为常量级，所以空间复杂度为O(1)

<hr>











# 三、最大子数组和

![Xnip2022-03-09_11-09-57](Greedy/Xnip2022-03-09_11-09-57.jpg)



![Xnip2022-03-09_11-08-56](Greedy/Xnip2022-03-09_11-08-56.jpg)

题意:

给你一个数组，请你返回其中最大的子数组之和





思路:

- 该题目可以动规，也可以贪心，但贪心比较难想到
- 在尝试得到一个子数组的时候，如果当前子数组的和为负数了，那么之后就算有其他的正数元素加入，该子数组也不会是和最大的子数组了
- 所以我们的局部最优解为: 忽略掉和为负数的子数组，只保留非数组的子数组和



复杂度:

- 我们遍历了一次原数组，所以时间复杂度为O(n)
- 我们创建的变量个数为常量级，所以空间复杂度为O(1)

<hr>













# 四、买卖股票最佳时机2

![Xnip2022-03-10_07-06-51](Greedy/Xnip2022-03-10_07-06-51.jpg)



![Xnip2022-03-10_07-14-22](Greedy/Xnip2022-03-10_07-14-22.jpg)

题意:

给你一个代表股票价格数组，请你计算出能够获取的最大收益



思路:

- 因为需要的是最大收益，所以我们应该保证每次都底价买入，之后高价卖出，所以我们需要的是股价上升的数字
- 分解一下，如果每次股价上升我们都计算在内，那么加起来就是总的最大收益了
- 将收益拆解为每天的话，我们只需要以两天为单位，收集正收益即可



复杂度:

- 我们遍历了一个参数数组，所以时间复杂度为O(n)
- 我们创建的变量个数为常量级，所以空间复杂度为O(1)

<hr>













# 五、跳跃游戏

![Xnip2022-03-11_07-12-46](Greedy/Xnip2022-03-11_07-12-46.jpg)



![Xnip2022-03-11_07-19-33](Greedy/Xnip2022-03-11_07-19-33.jpg)

题意:

给你一个数组，其中每个元素代表可以跳跃的最大距离，从第一个元素位置开始，请你判断能否跳到最后一个位置处





思路:

- 

- 因为每个位置可选的跳跃距离有很多，所以乍一看很迷惑
- 但用上贪心的话就容易想到: 我们只需要取能够跳跃的最远距离即可，只要最远距离能够触及最后一个索引位置的话，我们就能到达最后一个位置



复杂度:

- 我们遍历了一次输入数组，所以时间复杂度为O(n)
- 我们创建的变量个数为常量级，所以空间复杂度为O(1)

<hr>







# 六、跳跃游戏2

![Xnip2022-03-12_09-07-19](Greedy/Xnip2022-03-12_09-07-19.jpg)



![Xnip2022-03-12_09-16-07](Greedy/Xnip2022-03-12_09-16-07.jpg)

题意:

给你一个数组，其中每个元素代表该位置可以跳跃的最大距离，假设每个元素都能跳到最后一个位置处，请你得出跳到最后一个索引位置所需的最小跳跃次数





思路:

- 同昨天一样，基础的思路还是贪心，但这里我们需要考虑步数了
- 为了判断是否还需要再走一步，我们需要维护两个变量表示当前能够到达的最大距离，并在该范围内持续维护下一步能够到达的最大距离
- 如果下一步的最大距离已经可以到达终点了，那么就不再需要再走了
- 但如果已经到了当前能够到达的最大距离处，但下一步的最大距离还是无法到达最后，则需要再走下一步
- 从逻辑上看，这种方法其实需要考虑很多条件，比较麻烦
- 但其实我们可以简化一下，因为题目指明一定是能够到达终点的，反之，倒数第二个位置也一定能到达终点
- 所以我们只需要判断当前是先走过倒数第二个位置还是先到达当前的最大距离即可，如果是前者则不需要再做判断了，如果是后者则需要再走一步



复杂度:

- 我们遍历了一次输入数组，所以时间复杂度为O(n)
- 我们创建的变量个数为常量级，所以空间复杂度为O(1)

<hr>











# 七、K次取反最大和

![Xnip2022-03-13_08-27-57](Greedy/Xnip2022-03-13_08-27-57.jpg)



![Xnip2022-03-13_08-39-46](Greedy/Xnip2022-03-13_08-39-46.jpg)

题意:

给你一个数组，一个数字k，尝试获取将该数组中的任意个数字共取反k次后(改变符号)的最大和值





思路:

- 如果数组中有负数的话，那么很明显，需要优先将数组中的负数变为正数
- 为了让数组和最大，我们应该优先转变最小的负数，这里我们通过排序就能获取负数的大小次序，每次转换都递减k
- 之后，如果转换所有的负数后，k还是奇数的话，我们只需要改变最小元素的符号即可



复杂度:

- 最坏时我们需要进行两次排序，所以时间复杂度为O(nlogn)
- 我们创建的变量个数为常量级，所以空间复杂度为O(1)

<hr>









# 八、加油站

![Xnip2022-03-14_08-12-16](Greedy/Xnip2022-03-14_08-12-16.jpg)



![Xnip2022-03-14_08-11-09](Greedy/Xnip2022-03-14_08-11-09.jpg)

题意:

给你一个数组gas，其中每个元素代表在每个加油站可以获取的汽油数量，再给你一个数组cost，其中每个元素代表从该位置到下一个位置所需要的汽油数

请你返回一个数字，如果有能够绕完一圈回到终点的起始位置，那么就返回该位置对应的索引，没有则返回-1





思路:

- 从返回结果来看，该题目有两种结果，那么怎么区分是那种结果呢？其实很简单:
- 只需要判断一下绕完一圈后剩余的汽油是否小于0即可
- 如果大于等于0，那么就需要我们进一步处理了：
- 首先起始位置要成立的话，从该位置出发后的任何位置处都不应该出现剩余油量为负的情况
- 所以我们只需要维护一个变量来表示剩余油量，一旦该变量的值小于零，则说明当前起始位置不成立，我们需要更新到下一个位置处，并重置油量
- 综上，看起来我们需要遍历数组两次，其实计算总的剩余油量和当前剩余油量可以同步进行，所以一次遍历就够了，最后根据总剩余油量更新返回的数值即可



复杂度:

- 我们遍历了一次输入数组，所以时间复杂度为O(n)
- 我们创建的变量数为常量级，所以空间复杂度为O(1)

<hr>











# 九、发糖

![Xnip2022-03-15_07-47-13](Greedy/Xnip2022-03-15_07-47-13.jpg)



![Xnip2022-03-15_07-57-01](Greedy/Xnip2022-03-15_07-57-01.jpg)

题意:

给你一个数组，其中每个元素代表每个孩子的评分，请你为每个孩子分发糖果，其中每个孩子至少应该有一个糖果，如果相邻两个孩子中有一个评分较高，则他将获取更多的糖果，请你返回满足条件时需要的最少的糖果数量





思路:

- 评分高的获取更多糖果，这个条件可以具体化为：评分高的比相邻的至少多一个糖果
- 但问题就在于，这里相邻既可能是左边，也可能是右边，所以想一次搞定肯定不现实，很容易顾此失彼
- 所以我们可以将问题拆分为两边解决：先满足右边比左边大的情况，再满足左边比右边大的情况
- 所以，我们可以创建一个数组代表给每个孩子分配糖果的数量，并初始化每个元素为1
- 先从左到右遍历，比较右边孩子的评分是否大于左边，如果是则更新右边孩子的糖果为其左边的人 + 1
- 之后再处理左边比右边大的情况，这里需要从右往左了: 因为如果还是从左往右的话，原本比左边小的元素可能在之后的判断中再次进行了更改，并又比左边大了，这样之前的操作就失效了
- 两次遍历后，得到的数组就是答案了



复杂度:

- 我们遍历了两次rating数组，所以时间复杂度为O(n)
- 我们创建了一个新的数组用来记录每个孩子分得的糖果数量，所以空间复杂度为O(n)
















# 一、分发饼干

![Xnip2022-03-07_07-10-12](Greedy/Xnip2022-03-07_07-10-12.jpg)



![Xnip2022-03-07_07-16-42](Greedy/Xnip2022-03-07_07-16-42.jpg)

题意:

给你两个数组，其中一个数组中每个元素代表能满足一个孩子需要的饼干数量，另一个数组中的每个元素代表每个饼干的大小，请你尽可能多的喂饱孩子并返回满足的孩子数量





思路:

- 首先需要认识到，我们需要的是该题目的全局最优解，而贪心的思路就是将求全局最优解分解为局部最优解
- 贪心的问题就是怎样才能证明求局部最优解最终能解决全局最优解，其实贪心和动态规划一样没有固定套路，证明其有效的方法就是尝试举反例
- 在这里，我们局部最优解为先将大饼干分配给胃口大的孩子，尝试举反例后发现可行，所以能够得到全局最优



复杂度:

- 我们对两个数组进行了排序，所以时间复杂度为O(nlog(n) + mlog(m))
- 为了两个排序，我们需要一定的空间，所以空间复杂度为O(log(n) + log(m))

<hr>











# 二、摆动序列

![Xnip2022-03-08_07-10-21](Greedy/Xnip2022-03-08_07-10-21.jpg)



![Xnip2022-03-08_07-22-26](Greedy/Xnip2022-03-08_07-22-26.jpg)



![Xnip2022-03-08_07-25-44](Greedy/Xnip2022-03-08_07-25-44.jpg)

题意:

给你一个数组，请你计算出其中最长的摆动序列的长度



思路:

- 首先，摆动序列的条件为中间值在"山顶"或者"山谷"，在山脊部分的节点则不能统计在内
- 所以我们要做的就是判断当前节点前后的差值是否符合一个山顶或者山谷的条件，在code里体现在这一语句:if (curDiff > 0 && preDiff <= 0 || curDiff < 0 && preDiff >= 0)
- 有了方法后，我们只需要遍历该数组即可



复杂度:

- 我们遍历了一个输入数组，所以时间复杂度为O(n)
- 我们创建的变量个数为常量级，所以空间复杂度为O(1)

<hr>











# 三、最大子数组和

![Xnip2022-03-09_11-09-57](Greedy/Xnip2022-03-09_11-09-57.jpg)



![Xnip2022-03-09_11-08-56](Greedy/Xnip2022-03-09_11-08-56.jpg)

题意:

给你一个数组，请你返回其中最大的子数组之和





思路:

- 该题目可以动规，也可以贪心，但贪心比较难想到
- 在尝试得到一个子数组的时候，如果当前子数组的和为负数了，那么之后就算有其他的正数元素加入，该子数组也不会是和最大的子数组了
- 所以我们的局部最优解为: 忽略掉和为负数的子数组，只保留非数组的子数组和



复杂度:

- 我们遍历了一次原数组，所以时间复杂度为O(n)
- 我们创建的变量个数为常量级，所以空间复杂度为O(1)

<hr>













# 四、买卖股票最佳时机2

![Xnip2022-03-10_07-06-51](Greedy/Xnip2022-03-10_07-06-51.jpg)



![Xnip2022-03-10_07-14-22](Greedy/Xnip2022-03-10_07-14-22.jpg)

题意:

给你一个代表股票价格数组，请你计算出能够获取的最大收益



思路:

- 因为需要的是最大收益，所以我们应该保证每次都底价买入，之后高价卖出，所以我们需要的是股价上升的数字
- 分解一下，如果每次股价上升我们都计算在内，那么加起来就是总的最大收益了
- 将收益拆解为每天的话，我们只需要以两天为单位，收集正收益即可



复杂度:

- 我们遍历了一个参数数组，所以时间复杂度为O(n)
- 我们创建的变量个数为常量级，所以空间复杂度为O(1)

<hr>













# 五、跳跃游戏

![Xnip2022-03-11_07-12-46](Greedy/Xnip2022-03-11_07-12-46.jpg)



![Xnip2022-03-11_07-19-33](Greedy/Xnip2022-03-11_07-19-33.jpg)

题意:

给你一个数组，其中每个元素代表可以跳跃的最大距离，从第一个元素位置开始，请你判断能否跳到最后一个位置处





思路:

- 

- 因为每个位置可选的跳跃距离有很多，所以乍一看很迷惑
- 但用上贪心的话就容易想到: 我们只需要取能够跳跃的最远距离即可，只要最远距离能够触及最后一个索引位置的话，我们就能到达最后一个位置



复杂度:

- 我们遍历了一次输入数组，所以时间复杂度为O(n)
- 我们创建的变量个数为常量级，所以空间复杂度为O(1)

<hr>







# 六、跳跃游戏2

![Xnip2022-03-12_09-07-19](Greedy/Xnip2022-03-12_09-07-19.jpg)



![Xnip2022-03-12_09-16-07](Greedy/Xnip2022-03-12_09-16-07.jpg)

题意:

给你一个数组，其中每个元素代表该位置可以跳跃的最大距离，假设每个元素都能跳到最后一个位置处，请你得出跳到最后一个索引位置所需的最小跳跃次数





思路:

- 同昨天一样，基础的思路还是贪心，但这里我们需要考虑步数了
- 为了判断是否还需要再走一步，我们需要维护两个变量表示当前能够到达的最大距离，并在该范围内持续维护下一步能够到达的最大距离
- 如果下一步的最大距离已经可以到达终点了，那么就不再需要再走了
- 但如果已经到了当前能够到达的最大距离处，但下一步的最大距离还是无法到达最后，则需要再走下一步
- 从逻辑上看，这种方法其实需要考虑很多条件，比较麻烦
- 但其实我们可以简化一下，因为题目指明一定是能够到达终点的，反之，倒数第二个位置也一定能到达终点
- 所以我们只需要判断当前是先走过倒数第二个位置还是先到达当前的最大距离即可，如果是前者则不需要再做判断了，如果是后者则需要再走一步



复杂度:

- 我们遍历了一次输入数组，所以时间复杂度为O(n)
- 我们创建的变量个数为常量级，所以空间复杂度为O(1)


















# 1、层序遍历

![Xnip2021-11-05_08-10-54](Binary Tree/Xnip2021-11-05_08-10-54.jpg)



![Xnip2021-11-05_08-39-44](Binary Tree/Xnip2021-11-05_08-39-44.jpg)



![Xnip2021-11-05_09-38-21](Binary Tree/Xnip2021-11-05_09-38-21.jpg)



![Xnip2021-11-05_08-10-21](Binary Tree/Xnip2021-11-05_08-10-21.jpg)



![Xnip2021-11-05_09-45-50](Binary Tree/Xnip2021-11-05_09-45-50.jpg)

题意:

给你一颗二叉树，请你按照层序遍历的顺序返回其中每个节点的值

思路1:

- 层序遍历的顺序其实和广度优先遍历一样(BFS)，所以我们使用BFS就行了
- 依次遍历每层的节点，并将每层节点的值保存在一个集合中，每次遍历完一层之后，就将该层集合添加到结果集合中
- 最后返回这个结果集合即可

实现1:

- 创建一个结果集合，其记录每一层的节点值集合，首先判断参数根节点是否为空，为空则直接返回这个空的结果集合
- 创建一个队列，用其记录所有的节点，且以层序遍历的方式向里面添加节点
- 首先向队列中添加根节点
- 进入循环，条件为队列不为空，创建一个集合curLevel用来记录当前层所有节点的值
- 取出当前队列的长度queueSize，只遍历queueSize次，每次取出队列头的节点
- 判断该节点的左右子节点是否为空，不为空则添加到队列中用于之后的遍历
- 注意：我们只遍历了queueSize次，该值是固定的，代表该层节点的数目，这里不能使用queue.size()，因为我们判断取出节点的左右子节点后，向该队列中添加了它的左右子节点，此时队列的长度queue.size()是变化的，无法清晰的表示该层的节点数，这样一来我们就会将所有的节点值都添加到curLevel集合中了
- 添加完左右子节点后，将该节点的值添加到当前层集合中curLevel
- 遍历完当前层所有节点后，将记录该层所有节点值的集合curLeve添加到结果集合中
- 当队列为空后，返回结果集合

复杂度1:

- 我们遍历了所有的节点，所以时间复杂度为O(n)
- 我们记录了所有的节点值，所以空间复杂度为O(n)

注意事项1:

- 在遍历当前层节点时，应该先行取出当前层的节点，而不应该直接使用queue.size()，因为在向队列添加下一层节点时，该队列的长度是变化的，此时不再代表当前层节点的数量

思路2:

- 使用深度优先遍历，根据层级将节点值添加到对应的集合中
- 每当更新到下一层级后，都将层级数 + 1

实现2:

- 创建一个全局集合，创建一个dfs方法，传入节点和层级
- 判断集合中元素的数量和层级是否相等，相等则说明该层没有记录，该节点为该层第一个节点
- 所以我们为该层创建一个集合，将节点值记录到该层集合中
- 之后向下遍历左右子节点，并增加层级数

复杂度2:

- 我们遍历了二叉树中所有的节点，所以时间复杂度为O(n)
- 我们递归调用的栈空间取决于树的高度，但我们同时还创建了一个结果集合来记录所有的节点值，所以空间复杂度为O(n)





****

# 2、层序遍历倒序

![Xnip2021-11-06_14-29-32](../Algorithem/Xnip2021-11-06_14-29-32.jpg)

![Xnip2021-11-06_14-28-14](../Algorithem/Xnip2021-11-06_14-28-14.jpg)

![Xnip2021-11-06_14-28-37](../Algorithem/Xnip2021-11-06_14-28-37.jpg)

题意:

给你一颗二叉树，请你按照层序遍历的倒序顺序获取节点值并输出为一个二维集合

思路1:

- 根据昨天的思路，我们只需要在遍历每层节点后，将该层节点对应的集合添加到结果集合的开头即可

复杂度1:

- 同昨天

思路2:

- 使用深度优先遍历，根据层级将节点值添加到对应的集合中
- 每当更新到下一层级后，都将层级数 + 1

实现2:

- 创建一个结果集合，创建一个dfs方法，传入节点，层级和结果集合
- 判断集合中元素的数量和层级是否相等，相等则说明该层没有记录，该节点为该层第一个节点
- 所以我们为该层创建一个集合并返回到结果集合中的开头，将节点值记录到该层集合中
- 之后向下遍历左右子节点，并增加层级数

复杂度2:

- 我们遍历了所有的节点，所以时间复杂度为O(n)
- 我们创建了一个结果集合，我们递归的调用的栈空间取决于树的高度，所以空间复杂度为O(n)

****

# 3、锯齿状层序遍历

![Xnip2021-11-07_15-45-25](../Algorithem/Xnip2021-11-07_15-45-25.jpg)

![Xnip2021-11-07_15-31-21](../Algorithem/Xnip2021-11-07_15-31-21.jpg)

![Xnip2021-11-07_15-57-33](../Algorithem/Xnip2021-11-07_15-57-33.jpg)

题意:

给你一颗二叉树，请你以锯齿状层序遍历的顺序获取其中所有的节点值，并返回一个二维集合

思路1:

- 所谓的锯齿状其实就是每层的值都根据层数的奇偶进行前后顺序的交替
- 所以我们只需要在原本层序遍历的基础上，判断一下当前的层级，如果为奇数则将当前节点值添加到当前层集合的末尾，否则添加到开头
- 我们只需要更新层数即可，其余不变

复杂度1:

- 同层序遍历，所以时空复杂度都为O(n)

思路2:

- 我们其实还可以在添加下一层元素到队列的时候作出判断
- 如果当前层为奇数，则从队列的末尾位置获取当前层的元素，并将一下层的元素都添加到队列的开头
- 否则从队列的开始位置获取当前层元素，并将下一层元素都添加到队列的末尾

复杂度2:

- 同层序遍历，所以时空复杂度都为O(n)

****

# 4、二叉树最大直径(不熟悉)

![Xnip2021-11-08_07-46-57](../Algorithem/Xnip2021-11-08_07-46-57.jpg)

![Xnip2021-11-08_07-46-25](../Algorithem/Xnip2021-11-08_07-46-25.jpg)

题意:

给你一颗二叉树，请你计算出该二叉树的最大直径

思路:

- 二叉树的最大直径其实指的是最长的边数和，将该问题拆分，其实最长的边长等于左右子树的最长边长 + 根节点的边
- 又因为部分子树的边长和可能大于根节点，所以我们需要判断子树的最大边长是否大于整个树



实现:

- 传入根节点到dfs方法，该方法计算树的最大深度(子树的深度等于从根节点到叶子节点的边数)
- 将左右子树的最大深度相加即为该树的最大边，将其与当前最大边数对比，更新最大边数
- 返回左右子树中的最大节点数 + 1，作为该棵树的最大深度



复杂度:

- 我们遍历了所有的节点，所以时间复杂度为O(n)
- 我们递归调用的栈空间取决于二叉树的高度，所以空间复杂度为O(h)

****













# 5、二叉树最大路径和(不太熟)

![Xnip2021-11-09_08-16-39](../Algorithem/Xnip2021-11-09_08-16-39.jpg)

![Xnip2021-11-09_08-23-40](../Algorithem/Xnip2021-11-09_08-23-40.jpg)

题意:

给你一颗二叉树，请你返回其中最大的路径和

思路:

- 从根节点开始获取该二叉树中最大的路径和其实就是判断左右子树中谁的路径和大
- 这样问题就拆分为了判断子树中最大的路径和
- 我们通过递归的方法，最终会向下遍历到叶子节点
- 以该节点为根的子树的最大路径和值就是其节点值本身
- 向上一层后，最大的路径和值就是当前的根节点值 + 左子树最大和值 + 右子树最大和值
- 每当计算出当前子树的最大路径和值，就将其与当前的最大和值进行比较，从而更新结果值
- 需要注意的是，每棵子树在上一层中都会作为其中的一条边被计算，所以我们需要还需要返回该棵树左节点值 + 根节点值与右节点值 + 根节点值中的最大值

实现(Java):

- 创建一个类的成员变量maxSum作为结果值
- 在maxPathSum方法中调用getMaxEdgeSum方法，传入根节点
- 在getMaxEdgeSum中，如果参数节点为null(树为空或者当前以及遍历到了叶子结点)，则返回值为0(没有节点，值无效)
- 递归调用获取左右子树作为边的最大边值之和
- 将左右子树的最大边值加上当前树的根节点值作为当前树的最大路径和值，用了更新成员变量maxSum
- 最后返回该树作为边的最大边值和(找出左右子树值的最大值 + 当前树的根节点值)

****

# 6、最大深度

![Xnip2021-11-10_12-06-20](../Algorithem/Xnip2021-11-10_12-06-20.jpg)

![Xnip2021-11-10_12-21-57](../Algorithem/Xnip2021-11-10_12-21-57.jpg)

![Xnip2021-11-10_12-22-11](../Algorithem/Xnip2021-11-10_12-22-11.jpg)

题意:

给你一颗二叉树给你返回它的最大深度

思路1:

- 对于每棵二叉树而言，最大的深度为左右子树的中的最大深度值 + 1(根节点算一个)
- 所以我们需要获取左右子树的最大深度值，这样就可以一直将问题分解到叶子节点
- 最后叶子节点的深度只能为1，所以我们使用深度优先遍历，通过递归的方式就能解决了

复杂度1:

- 我们遍历了所有的节点，所以时间复杂度为O(n)
- 我们递归调用的栈空间取决于树的高度，所以空间复杂度为O(h)

思路2:

- 既然深度优先可行，那么广度优先呢？
- 当然可以，我们每遍历完一层后就将层级加一，最后返回层级不就行了吗?

复杂度2:

- 我们遍历了所有的节点，所以时间复杂度为O(n)
- 我们用队列保存了所有的节点，所以空间复杂度为O(n)

<hr>



# 7、最小深度(不熟悉，用BFS)

![Xnip2021-11-11_07-39-11](../Algorithem/Xnip2021-11-11_07-39-11.jpg)



![Xnip2022-06-14_07-57-18](Binary Tree/Xnip2022-06-14_07-57-18.jpg)



![Xnip2021-11-11_07-38-33](../Algorithem/Xnip2021-11-11_07-38-33.jpg)







题意:

给你一颗二叉树，请你计算出其最小的深度

思路1:

- 对于一棵树而言，要获取其最小深度一定需要先判断其左右子树的深度，最后返回其中的最小值 + 1即可(加上当前树的根节点)
- 向下一直到根节点则深度为1，通过这种方法，我们就能自下而上的计算出所有子树的深度，从而返回其中的较小值了

复杂度1:

- 我们遍历了所有的节点，所以时间复杂度为O(n)
- 我们递归调用的栈空间取决于树的深度，所以空间复杂度为O(h)

思路2:

- 在方法1中，我们遍历了所有的节点，但其实并不需要
- 如果我们通过遍历左子树获取的深度为2，在遍历右子树时如果还没遍历完深度就以及到了2，则不需要继续遍历了，可以直接打断，这样就避免了很多不必要的计算，也就是所谓的"剪枝"

复杂度2:

- 最坏的情况下我们还是需要遍历所有的节点，所以时间复杂度为O(n)
- 我们递归调用所需的栈空间取决于最小的树深度，所以最坏时空间复杂度为O(h)

****

# 8、翻转二叉树

![Xnip2021-11-12_07-20-53](../Algorithem/Xnip2021-11-12_07-20-53.jpg)

![Xnip2021-11-12_07-22-56](../Algorithem/Xnip2021-11-12_07-22-56.jpg)

![Xnip2021-11-12_07-23-09](../Algorithem/Xnip2021-11-12_07-23-09.jpg)

题意:

给你一颗二叉树，请你将其翻转后返回其根节点

思路1:

- 所谓的翻转其实就是交换每个节点的左右子节点
- 而我们需要对每个节点都进行这样的操作，所以在交换的同时还需要遍历，使用深度优先就行了

实现1:

- 首先交换根节点对应的两个子节点，之后递归调用本方法，以同样的方式处理其左右子树
- 这样一来我们递归完整棵树之后，整棵树都完成了翻转

复杂度1:

- 我们遍历了整棵树，所以时间复杂度为O(n)
- 我们递归调用的栈空间取决于树的高度，最坏时树可能为一个链表，所以空间复杂度为O(n)

思路2:

- 遍历能用深度优先，那能不能用广度优先呢？当然可以，个人也不太喜欢写递归
- 同层序遍历一样，我们创建一个队列，其记录所有的节点
- 每次取出一个节点，就交换其对应的左右子节点，并将其左右子节点添加到队列中直到队列为空

实现2:

- 创建一个队列，将根节点添加到其中
- 进入循环，如果队列不为空，则取出队列头的节点，交换这个节点的左右子节点
- 之后将该节点的左右子节点添加到队列中，重复步骤直到队列为空

复杂度2:

- 我们遍历了整棵树，所以时间复杂度为O(n)
- 我们用队列存储了所有的节点，所以空间复杂度为O(n)

****

# 9、重建二叉树(需练习)

![Xnip2021-11-13_13-09-32](../Algorithem/Xnip2021-11-13_13-09-32.jpg)

![Xnip2021-11-13_13-16-29](../Algorithem/Xnip2021-11-13_13-16-29.jpg)

题意:

给你两个数组，其中一个是先序遍历二叉树所有节点值的结果，另一个是中序遍历二叉树所有节点值的结果，请你重新构建该二叉树，并返回其根节点

思路:

- 想要重建一颗二叉树，那么就要确定其根节点和左右子树
- 根据先序遍历的性质，先序遍历中的第一个元素必然是根节点
- 获取当前树的根节点后，在中序遍历中定位根节点的位置
- 根据先序遍历的性质，根节点左边的节点就都是左子树的节点了，右边则都是右子树的节点
- 我们先构建当前的根节点，之后则需要构建其对应的左右子树了
- 构建左右子树的方式和上述方式一样，但我们需要知道左右子树的先序遍历根节点索引和中序遍历的左右边界索引
- 左子树很简单，在先序遍历中原根节点的后一位就是左子树的根节点，左边边界不变，而右边界其实就是原根节点在中序遍历中的前一个位置(根节点在中序遍历中将所有节点分为两个部分，左边都是左子树的节点)
- 右子树稍微有些棘手，其根节点在先序遍历中的位置其实就是原根节点先序遍历索引 + 左子树的节点数量 + 1，说白了，越过了左子树和原根节点后，第一个节点就是右子树的根节点
- 问题是怎么获取左子树的节点数量呢？其实用原根节点中序遍历的索引位置 - 原中序遍历左边界的索引即可
- 而其左边界就是原根节点中序遍历索引的下一个位置，右边界不变

实现:

- 首先创建一个全局的HashMap用了关联中序遍历中节点的值和索引，方便之后通过根节点的值快速找到其在中序遍历中的索引
- 遍历中序遍历数组，填充我们的HashMap，将当前的根节点在先序遍历中的索引，左右边界在中序遍历中的索引传入递归方法buildHelper中
- 在递归方法中，首先根据根节点的索引获取根节点的值，并构建该根节点
- 根据该根节点的值通过HashMap获取根节点在中序遍历中的索引
- 递归调用本方法，构建左右子树
- 构建左子树时，传入的左子树先序遍历根节点索引为rootIdxInPreorder + 1即当前根节点的后一个位置，而中序遍历左边界索引与之前一致，但右边界索引为rootIdxInInorder - 1即原根节点在中序遍历索引的前一个位置
- 构建右子树时，传入的左子树先序遍历根节点索引为rootIdxInPreorder + nodeNumOfLeftSubTree + 1，也就是原根节点索引 + 左子树节点数 + 1
- 而左边界索引为rootIdxInInorder + 1即原根节点在中序遍历索引的后一个位置，中序遍历右边界索引与之前一致
- 最后返回根节点即可

复杂度:

- 我们遍历了所有的节点，所以时间复杂度为O(n)
- 我们创建了一个hash表，递归调用的栈空间取决于树的高度，所以空间复杂度为O(n)

****

# 10、最近公共祖先(不熟悉)

![Xnip2021-11-14_14-43-04](../Algorithem/Xnip2021-11-14_14-43-04.jpg)



![Xnip2021-11-14_15-17-23](../Algorithem/Xnip2021-11-14_15-17-23.jpg)

题意:

给你一颗二叉树，和两个其中的节点，请你找出这两个节点在二叉树中的最近公共祖先节点

思路:

- 从结果来看，其实有两种情况:
- 按照常规的dfs进行搜索的话，当前节点的左右子节点/子树中可能各自存在一个目标节点
- 这种情况下我们只需要向下搜索找到最近的即可
- 但如果搜素后发现两个目标节点在同一颗子树中(左或者右)，则说明其中一个目标节点所在层级在另一个的上面且是其父节点
- 这种情况下我们则只需要返回最上层的那个目标节点即可
- 也就是说，我们从根节点开始搜索后，根据左右子树的结果就可以判断了

实现:

- 首先判断当前节点是否为null(到达了叶子节点)或者是否等于目标节点
- 是则返回当前节点，不是则继续搜索左右子树
- 根据左右子树的搜索结果，如果其中一个子树中没有目标节点，则直接返回另一颗子树中的搜索结果(其中的最上层节点)
- 如果两个子树的结果都不为空，则返回当前根节点(说明当前根节点为结果)

复杂度:

- 最坏时，我们会遍历所有的节点，所以时间复杂度为O(n)
- 递归调用的栈空间取决于树的高度，最坏时树为链表状，所以空间复杂度为O(n)

****

# 11、对称二叉树

![Xnip2021-11-15_08-36-10](../Algorithem/Xnip2021-11-15_08-36-10.jpg)

![Xnip2021-11-15_08-38-26](../Algorithem/Xnip2021-11-15_08-38-26.jpg)

![Xnip2021-11-15_08-37-05](../Algorithem/Xnip2021-11-15_08-37-05.jpg)



![D2575BE1-ECEB-4A4E-942F-B1DECC37EE8B](Binary Tree/D2575BE1-ECEB-4A4E-942F-B1DECC37EE8B.png)

题意:

给你一颗二叉树，请你判断其是否对称

思路1:

- 要判断是否对称其实就是判断左右子树中每个对应的节点对应的值相同
- 所以每次对比都需要两个节点，在每层遍历中，一旦其中一个子树对应的节点为空而另一个不为空，或者两者之间的值不相等，则返回false
- 如果两个节点都为null，则说明已经遍历到了叶子结点

实现1:

- 编写一个bfs方法，传入根节点作为左右节点
- 判断左右节点是否都为null以判断是否到达叶子结点
- 再判断是否存在其中一个节点为null，或者两节点值不等的情况
- 最后递归调用来判断子树

复杂度1:

- 我们遍历了所有的节点，所以时间复杂度为O(n)
- 递归调用的栈空间取决于树的高度，所以空间复杂度为O(n)

思路2:

- 上一种方法是dfs，同样用bfs也是可以的
- 创建一个队列，传入根节点两次
- 在循环中，每次取出两个节点(保证两个节点都是左右子树对称位置的节点)
- 判断两个节点是否全部为null(是否到达叶子结点)
- 再判断两个节点是否有一个为null或者节点值不同，如有则返回false
- 之后将左右子树对应位置的节点两两一组添加到队列中
- 遍历完整棵树后没有被打断，则说明整棵树对称，返回true

复杂度2:

- 我们遍历了所有的节点，所以时间复杂度为O(n)
- 我们创建了队列来存储所有的节点值，所以空间复杂度为O(n)

****



# 12、重建二叉树(中序/后序)注意边界

![Xnip2021-11-16_08-38-28](../Algorithem/Xnip2021-11-16_08-38-28.jpg)



![Xnip2021-11-16_08-59-14](../Algorithem/Xnip2021-11-16_08-59-14.jpg)



![Xnip2022-06-20_08-07-48](Binary Tree/Xnip2022-06-20_08-07-48.jpg)



![Xnip2021-11-16_09-54-34](../Algorithem/Xnip2021-11-16_09-54-34.jpg)

题意:

给你一颗二叉树中序遍历和后序遍历的结果，请你还原这颗二叉树并返回根节点

思路:

- 后序遍历有一个特点: 最后遍历的节点一定是根节点，而根节点在中序遍历中将所有的节点按照左右子树分为了左右两个部分
- 根据后续遍历，我们能够获取到根节点的值，在中序遍历数组中就能获取到根节点的索引值，从而就能获取到左右子树的边界索引，从而递归调用构建左右子树
- 这样看来其实思路和用前序遍历与中序遍历构建二叉树的方法差不多，只不过获取根节点的方式从前序遍历的开头变成了后序遍历的末尾位置而已

实现:

- 同之前的构建步骤相同，我们同样创建一个hashmap，用了记录中序遍历的值和对应的索引，方便之后直接通过根节点值获取到根节点的索引位置，从而获取左右子树的边界
- 遍历中序遍历数组填充hashmap，将左右子树在中序和后序遍历中的左右边界传入递归方法
- 在递归方法中，首先根据后序遍历的右边界获取到当前树的根节点值，构建该根节点，并通过hashmap获取根节点在中序遍历中的索引位置rootIdxInorder
- 根据根节点在中序遍历中的位置和树的中序遍历左边界获取左子树节点的数量curLeftTreeLen
- 递归调用构建左右子树
- 先说左子树:
  - 其在中序遍历中的左边界不变，右边界就是根节点的前一个位置(rootIdxInorder - 1)
  - 在后续遍历中的左边界不变，右边界其实就是左边界加上左子树节点的数量 - 1
  - 但如何获取左子树节点的数量呢？其实就是根节点在中序遍历中的索引 - 中序遍历中左子树边界(rootIdxInorder - startIdxInorder)
- 右子树:
  - 其在中序遍历中的左边界就是根节点的后一个位置，右边界不变
  - 后续遍历的左边界可以根据后续遍历的性质: 左子树之后就是右子树，而我们上面已经有了左子树的右边界，所以该值 + 1就是右子树的左边界
  - 而右边界就是根节点的前一个位置
- 这样我们就构建了左右子树，最后返回根节点即可

复杂度:

- 我们遍历了所有的节点，所以时间复杂度为O(n)
- 我们创建了一个hash表，递归调用的栈空间取决于树的高度，所以空间复杂度为O(n)

****





# 13、验证二叉搜索树(不熟悉)

![Xnip2021-11-17_12-31-04](../Algorithem/Xnip2021-11-17_12-31-04.jpg)

![Xnip2021-11-17_12-41-21](../Algorithem/Xnip2021-11-17_12-41-21.jpg)

![Xnip2021-11-17_12-52-05](../Algorithem/Xnip2021-11-17_12-52-05.jpg)

题意:

给你一颗二叉树，请你判断其是否为一颗二叉树搜索树

思路1:

- 我们可以直接利用中序遍历的性质: 中序遍历的顺序就是中 - 左 - 右
- 而一颗二叉搜索树通过中序遍历后，节点值一定是严格递增的，因此我们只需要对该二叉树进行一次中序遍历
- 每次遍历都比较当前节点值与遍历集合中最后一个值的大小关系，一旦有不符合的情况则说明该二叉树不是二叉搜索树

复杂度1:

- 我们遍历了所有的节点，所以时间复杂度为O(n)
- 我们创建了一个集合来记录中序遍历后的所有节点，所以空间复杂度为O(n)

思路2:

- 在比较时，我们其实只需要集合中的最后一个数，所以我们只需要维护最后一个数即可，不需要创建一个集合来记录所有的节点
- 在判断左右子树时，只要左子树为false则可以直接返回false了，没必要和右子树一起判断了

复杂度2:

- 我们遍历了所有的节点，所以时间复杂度为O(n)
- 递归调用所需的栈空间取决于树的高度，所以最坏时空间复杂度为O(n)

****

# 14、二叉树的右视图

![Xnip2021-11-18_08-19-23](../Algorithem/Xnip2021-11-18_08-19-23.jpg)

![Xnip2021-11-18_08-21-23](../Algorithem/Xnip2021-11-18_08-21-23.jpg)

![Xnip2021-11-18_08-40-46](../Algorithem/Xnip2021-11-18_08-40-46.jpg)

题意:

给你一颗二叉树，请你找出其中所有的右视图节点并将它们的值作为一个集合返回

思路1:

- 所谓的右视图其实就是每层节点中最靠右的那个罢了，因此如果我们使用BFS的话，每层遍历到最后的那个节点就是"右视图节点"
- 所以我们只需要取每层中从左到右的最后一个节点即可

复杂度1:

- 时空复杂度同层序遍历一样，都为O(n)

思路2:

- 之前我们在解决层序遍历的时候，写出了一个dfs的版本，其每次都判断当前层级和结果集合的长度
- 如果相同则说明该节点为当前层第一个访问的节点，所以需要为当前层创建一个集合并添加当前节点值到当前层集合中
- 在现在这个问题中，我们只需要"右视角"节点，所以我们不再需要维护一个当前层集合，只需要保证每次向下层访问时都先访问最右边的节点并添加其值到结果集中即可

复杂度2:

- 时空复杂度同样和层序遍历相同，都为O(n)

****

# 15、打家劫舍3

![Xnip2021-11-19_08-36-38](../Algorithem/Xnip2021-11-19_08-36-38.jpg)

![Xnip2021-11-19_09-01-16](../Algorithem/Xnip2021-11-19_09-01-16.jpg)

![Xnip2021-11-19_09-25-22](../Algorithem/Xnip2021-11-19_09-25-22.jpg)

题意:

如题，小偷想要打劫的房屋以二叉树的形状分布，如果同时打劫相邻节点的房屋会触发警报，在不触发警报的情况下，请你计算出能盗取的最大金额

思路1:

- 对于每个节点都有两个状态: 打劫或者不打劫
- 如果打劫当前节点则其总金额为当前节点值 + "孙子"节点值
- 如果不打劫则为其所有子节点的值之和
- 因此我们只需要判断并返回这两个值之间的最大值即可

实现1:

- 上述过程很简单，只需要计算其中一种情况例如: curNode.val + (curNode.left.left.val + curNode.left.right.val + curNode.right.left.val + curNode.right.right.val)，再与另一种情况比较即可，例如: curNode.left.val + curNode.right.val
- 在递归计算的过程中，其实我们重复计算了很多节点对应的值，所以我们可以记录下每个节点对应的值，从而避免重复计算，使用一个HashMap即可

复杂度1:

- 我们遍历了所有的节点，所以时间复杂度为O(n)
- 我们创建了一个HashMap，递归调用的栈空间取决于树的高度，所以空间复杂度为O(n)

思路2:

- 从思路上看，每个节点值都有两种状态的金额之和，那么我们直接为每个节点记录这两种状态不就行了吗？
- 用一个长度为2的数组记录当前节点的两种状态，为0则说明当前节点不被计算在内，为1则说明该节点被计算在内
- 为0时，当前节点的金额之后应该为子节点的金额之和最值
- 为1时，则说明不计算两个子节点，因此值为curNode.val + leftChild[0] + rightChild[0]
- 最后返回当前节点对应的数组，获取其中最大的元素即可

复杂度2:

- 我们遍历了所有的节点，所以时间复杂度为O(n)
- 递归调用的栈空间取决于树的高度，所以空间复杂度为O(n)

****

# 16、重建二叉搜索树

![Xnip2021-11-20_16-16-55](../Algorithem/Xnip2021-11-20_16-16-55.jpg)

![Xnip2021-11-20_16-16-03](../Algorithem/Xnip2021-11-20_16-16-03.jpg)

题意:

给你一颗二叉搜索树的先序遍历结果数组，请你重建该二叉搜索树

思路:

- 作为一颗二叉搜索树，其实将先序遍历的结果排序后就是它的中序遍历结果
- 因此，在获取中序遍历后，该题目就变为了通过先序和中序遍历来重建二叉树了
- 这种方法很简单，但效率不高，因为我们需要排序，还需要创建一个hashmap
- 对于二叉搜索树而言，其实只用先序遍历也是可以的
- 首先先序遍历的第一个元素一定为该树的根节点，剩下的就是在左右子树中找到子树的先序遍历根节点索引
- 根据二叉搜索树的特性，左边的节点值一定小于根节点值，所以我们可以通过二分法找到其中最接近根节点的左子树节点索引，从而将左右子树分隔开来
- 递归调用后传入子树的左右边界索引，即可构建左右子树
- 最后返回根节点即可

复杂度:

- 我们构建了每个节点，但每层之后都用二分法寻找边界节点，所以时间复杂度为O(nlog(n))
- 我们递归调用的栈空间取决于树的高度，所以最坏时空间复杂度为O(n)

****

# 17、重建二叉树总结

![Xnip2021-11-21_16-55-37](../Algorithem/Xnip2021-11-21_16-55-37.jpg)



![Xnip2021-11-21_16-55-51](../Algorithem/Xnip2021-11-21_16-55-51.jpg)



![Xnip2021-11-21_16-56-00](../Algorithem/Xnip2021-11-21_16-56-00.jpg)

****









# 18、路径之和

![Xnip2021-11-22_08-27-00](../Algorithem/Xnip2021-11-22_08-27-00.jpg)



![Xnip2021-11-22_08-34-56](../Algorithem/Xnip2021-11-22_08-34-56.jpg)



![Xnip2021-11-22_08-03-14](../Algorithem/Xnip2021-11-22_08-03-14.jpg)



![Xnip2021-11-22_08-24-41](../Algorithem/Xnip2021-11-22_08-24-41.jpg)

![Xnip2021-11-22_08-24-56](../Algorithem/Xnip2021-11-22_08-24-56.jpg)

题意:

给你一颗二叉树，和一个目标数，请你判断该二叉树中是否存在从根节点到叶子结点的路径和等于目标数

先导:

- 做这道题目之前，首先来解决AlgoExpert上的一道题目: 同样是路径和，但其只需要我们获取所有路径之和
- 解决该题目只需要使用dfs向下搜索，一旦抵达叶子结点，则将当前的和添加到结果集中即可

思路:

- 先导题目和leetcode上这道有什么关系？
- 其实我们只需要在到达叶子节点的时候判断一下路径和是否等于目标数，就能解决这道题目了，方法和先导题目一样，不过在实现的时候为了简洁，我们每次递归都将该目标数 - 当前节点值的差值作为下一次递归调用的目标和
- 同样的，我们也可以通过BFS的方式，通过逐层的方式计算每条路径和，一旦获取到对应的路径则返回true即可，与平时的BFS不同的是，我们还需要额外创建一个队列来记录从根节点到当前节点的路径和

复杂度:

- 不管什么方法，我们都遍历了所有的节点，所以时间复杂度为O(n)
- 我们递归调用的栈空间取决于树的高度，队列也存储了所有的节点，所以空间复杂度为O(n)









****

# 19、路径之和2

![Xnip2021-11-23_08-03-41](../Algorithem/Xnip2021-11-23_08-03-41.jpg)

![Xnip2021-11-23_08-18-25](../Algorithem/Xnip2021-11-23_08-18-25.jpg)

![Xnip2021-11-23_08-46-24](../Algorithem/Xnip2021-11-23_08-46-24.jpg)

题意:

给你一颗二叉树，一个目标数，请你获取该二叉树中从根节点到叶子结点的所有路径中，所有路径和等于目标数的路径值的集合

思路1:

- 与路径和1一样，我们其实也只需要维护一个当前路径和，当节点为叶子结点且路径和等于目标值时，将对应的路径添加到结果集中
- 所以我们还需要维护一个集合，用了记录当前路径中节点的值

实现1:

- 从根节点开始遍历，调用递归方法
- 每次调用中都先累加当前的路径和，并添加当前的节点值到新的集合中
- 如果到达了叶子结点，且路径和等于目标和，则将该路径对应的集合添加到结果集合中

复杂度1:

- 我们遍历了所有的节点，最坏时需要添加所有的路径，所以时间复杂度为O(n^2)
- 我们递归调用的栈空间与树的高度有关，我们每次递归调用都创建了一个新的集合，所以空间复杂度为O(n^2)

思路2:

- 上述思路中，我们每次都创建了一个新的集合，但其实不用这样做
- 我们只需要到达叶子节点且等于目标和的时候返回一个新的集合即可
- 但这样做的话，路径和集合就是所有路径公用的了，当一条路径中添加节点并加入到结果集后，其他路径怎么使用这个集合呢？
- 其实我们只需要在路径被添加到结果集后，将末尾的节点移除即可，这样就能用在其他路径中了

复杂度2:

- 我们遍历了所有的节点，最坏时需要添加所有的路径，所以时间复杂度为O(n^2)
- 我们递归调用的栈空间与树的高度有关，所以空间复杂度为O(n)

****

# 20、路径之和3

![Xnip2021-11-24_08-31-19](../Algorithem/Xnip2021-11-24_08-31-19.jpg)



![Xnip2021-11-24_08-53-16](../Algorithem/Xnip2021-11-24_08-53-16.jpg) 

题意:

给你一颗二叉树，一个目标数，请你找出其中路径和等于该目标数的路径数量

思路:

- 因为不限制从根节点到叶子节点了，所以我们可以通过两个节点之间的路径之差获取目标和
- 而非叶子节点的路径之和其实就是前缀和，而前缀和之差为目标和也就说明其中节点值之差为目标和
- 因此formula为: 当前节点的前缀和 - 目标前缀和 = 目标数
- 变换一下，当前节点所需要的前缀和就是当前节点的前缀和 - 目标数，如果存在这个目标前缀和则将其数量统计到结果中
- 所以我们需要将前缀和与数量进行对应，因此需要一个map
- 但我们在计算时前缀和是公用的，所以一旦搜索完了一条路径就需要删除当前的前缀和用来计算另外的路径

实现:

- 创建一个map将前缀和与对应的数量映射起来
- 首先将根节点前缀和0，与数量1对应起来
- 进入递归方法，传入根节点和当前路径和以及目标数
- 在递归方法中，如果节点为null则中断，累加路径和，累加符合当前路径和条件的前缀和数量到结果集中
- 记录当前节点的前缀和到map中
- 搜索左右子树
- 搜索完成后删除尾节点在map中的计数，用来计算其他路径

复杂度:

- 我们遍历了所有的节点，所以时间复杂度为O(n)
- 我们递归调用的栈空间取决于树的高度，其中Map所占空间也与n相关，所以空间复杂度为O(n)

****

# 21、二叉树的遍历(重要)

## 1) 前序

![Xnip2021-11-25_08-36-39](../Algorithem/Xnip2021-11-25_08-36-39.jpg)

![Xnip2021-11-25_09-06-34](../Algorithem/Xnip2021-11-25_09-06-34.jpg)

<hr>





## 2) 中序

![Xnip2021-11-25_09-07-38](../Algorithem/Xnip2021-11-25_09-07-38.jpg)



![Xnip2021-11-25_09-06-42](../Algorithem/Xnip2021-11-25_09-06-42.jpg)

<hr>







## 3) 后序

![Xnip2021-11-25_07-55-33](../Algorithem/Xnip2021-11-25_07-55-33.jpg)





![Xnip2022-05-20_11-38-59](Binary Tree/Xnip2022-05-20_11-38-59.jpg)

****





# 22、从根节点到页节点的数字和

![Xnip2021-11-26_08-25-45](../Algorithem/Xnip2021-11-26_08-25-45.jpg)

![Xnip2021-11-26_08-56-48](../Algorithem/Xnip2021-11-26_08-56-48.jpg)

![Xnip2021-11-26_08-47-47](../Algorithem/Xnip2021-11-26_08-47-47.jpg)

题意:

给你一颗二叉树，请你计算出从根节点到叶子结点中所有节点的数字之和(上层元素向高位移一位)

思路1:

- 因为每层元素的值都比下一层高一位，也就是*10
- 那么我们可以记录下每条路径的当前和值，每到下一层，则将下一层的值 + 当前值 * 10，所以可以用BFS
- 一旦遍历到了叶子结点，那么将路径的和值累加到结果中即可

思路2:

- 因为我们只需要获取每一条路径的和值，所以我们可以通过dfs的方式搜索每条路径，到达叶节点后返回和值即可

复杂度:

- 两种方式都遍历了所有的节点，所以时间复杂度为O(n)
- 我们创建的队列记录了所有的节点，我们递归调用的栈空间取决于树的高度，所以空间复杂度都为O(n)

****

# 23、合并二叉树

![Xnip2021-11-27_08-08-32](../Algorithem/Xnip2021-11-27_08-08-32.jpg)

![Xnip2021-11-27_08-15-57](../Algorithem/Xnip2021-11-27_08-15-57.jpg)

题意:

给你两颗二叉树，请你将该二叉树"合并"起来(将两二叉树相同位置节点的值相加，如果其中一个为null，则另一个不为null的设置为该节点的值)

思路:

- 首先判断两个节点中是否有一个为null，有则直接返回另一个节点
- 如果都不为null，则获取两节点值之和后构建一个节点
- 通过递归调用的方法构造该的节点的左右子节点
- 最后返回即可

复杂度:

- 我们遍历节点的数量取决于节点数少的那颗，所以时间复杂度为O(min(n, m))
- 我们递归调用的栈空间也取决于节点数少的那颗，所以空间复杂度为O(min(n, m))

****

















# 24、寻找后续节点

![Xnip2021-11-28_09-15-45](../Algorithem/Xnip2021-11-28_09-15-45.jpg)



![Xnip2021-11-28_09-51-12](../Algorithem/Xnip2021-11-28_09-51-12.jpg)

题意:

给你一颗二叉树，一个目标节点，请你找出该目标节点在中序遍历中的后一个节点







思路:

- 中序遍历其实很简单，这里用栈-迭代的方式做
- 将再中序遍历的集合遍历一次，一旦找到目标节点，则直接返回下一个节点即可



复杂度:

- 

- 我们遍历了所有的节点，所以时间复杂度为O(n)
- 我们创建了一个集合来存储所有的节点，所以空间复杂度为O(n)

****















# ============================















# 25、二叉搜索树的最近公共祖先

![Xnip2021-11-29_08-03-53](../Algorithem/Xnip2021-11-29_08-03-53.jpg)



![Xnip2021-11-29_08-02-30](../Algorithem/Xnip2021-11-29_08-02-30.jpg)



![Xnip2021-11-29_08-02-39](../Algorithem/Xnip2021-11-29_08-02-39.jpg)

题意:

给你一颗二叉搜索树，和两个目标节点，请你返回这两个目标节点的最近公共祖先节点





思路:

- 单说解题的话，其实看作二叉树也能解决，但这样没有用到二叉搜索树的性质，有些可惜
- 在解题的时候，我们其实需要判断两个目标节点在当前根节点的左边还是右边
- 而二叉搜索树的节点值大小刚好能够用来做这样的判断：
- 如果都在同一侧，那么当前根节点和两个目标节点的差值之积一定大于0(都小于0，或者都大于0)
- 而如果不在同一侧，那么我们继续向对应的方向搜索就是了，当然也可以反过来，将同侧搜索的过程通过递归的方式实现



复杂度:

- 最坏时需要我们遍历所有的节点，所以时间复杂度为O(n)
- 我们没有创建与n相关的任何额外空间，所以空间复杂度为O(1)

****



















# 26、二叉搜索树的第k大的节点值

![Xnip2021-11-30_08-30-12](../Algorithem/Xnip2021-11-30_08-30-12.jpg)



![Xnip2021-11-30_08-36-07](../Algorithem/Xnip2021-11-30_08-36-07.jpg)

题意:

给你一颗二叉搜索树，请你获取其中第k大的节点值









思路:

- 鉴于二叉搜索树的特性，我们可以直接通过中序遍历的方式获取其中所有的节点，之后再获取倒数第k个节点即可
- 但这样做的话需要创建额外的空间
- 其实我们将中序遍历的顺序修改一下，遍历的时候先搜索右子树，此时获取节点的顺序就是中序遍历的倒序
- 那么我们只需要按照这样的顺序遍历k次即可



复杂度:

- 

- 最坏的情况下，我们需要遍历所有的节点，所以时间复杂度为O(n)
- 最坏时，我们需要递归到最右节点中，所以空间复杂度为O(n)

****





















# 27、构建最小高度树

![Xnip2021-12-01_15-10-03](../Algorithem/Xnip2021-12-01_15-10-03.jpg)



![Xnip2021-12-01_15-09-45](../Algorithem/Xnip2021-12-01_15-09-45.jpg)



![Xnip2021-12-01_15-23-14](../Algorithem/Xnip2021-12-01_15-23-14.jpg)

题意:
给你一个有序的数组，请你通过该数组构建出一个最小的二叉搜索树





思路:

- 构建二叉树其实就是构建根节点，再连接上左右节点
- 而对于有序数组来说，根节点就是数组中间位置的数字，所以每次获取中间节点即可



复杂度:

- 我们访问了所有的节点，所以时间复杂度为O(n)
- 我们通过二分的方式构建了树，所以空间复杂度为O(log(n))

<hr>























# 28、恢复二叉搜索树

![Xnip2021-12-02_08-17-10](../Algorithem/Xnip2021-12-02_08-17-10.jpg)



![Xnip2021-12-02_08-15-43](../Algorithem/Xnip2021-12-02_08-15-43.jpg)



![Xnip2021-12-02_08-16-02](../Algorithem/Xnip2021-12-02_08-16-02.jpg)

题意:

给你一颗二叉树，只需要交换其中两个节点就能将其变为一颗二叉搜索树，请你将其恢复为二叉搜索树





思路:

- 首先肯定是需要找到这两个节点了
- 因为两个节点的值应该交换，所以其对应的大小关系也应该相反
- 那么在中序遍历时，其中一个节点应该小于前一个节点，而另一个应该大于其后面一个节点
- 如何在搜索中设置这两个节点？
- 其实设置两个引用，首先获取第一个节点(小于前一个节点时，设置前一个节点为第一个节点)
- 当第一个节点的引用不为null的时候，此时再设置第二个错误节点(后一个节点)
- 最后交换两个节点的值即可
- 其中中序遍历可以通过递归，也可以通过迭代，所以有两种写法



复杂度:

- 我们遍历了所有的节点，所以时间复杂度为O(n)
- 我们递归调用和迭代的栈空间都为n，所以空间复杂度为O(n)

****























# 29、链表到二叉搜索树

![Xnip2021-12-03_08-18-58](../Algorithem/Xnip2021-12-03_08-18-58.jpg)



![Xnip2021-12-03_09-39-23](../Algorithem/Xnip2021-12-03_09-39-23.jpg)



![Xnip2021-12-03_09-40-44](../Algorithem/Xnip2021-12-03_09-40-44.jpg)

题意:

给你一个有序链表，请你将其构建为一颗二叉搜索树







思路1:

- 最简单的方法就是将该链表的所有节点值写入到一个集合中，使用二分法构建即可
- 其实链表也能这样做，不过需要我们获取中间节点
- 那么如何获取中间节点呢？
- 快慢指针呗！每次都创建两个指针，一块一慢，这样慢指针最终指向的就是中间节点了
- 之后构建中间节点，以中间节点为分界构建左右子树即可(注意要断开左子树)



复杂度1:

- 这样做的话需要我们多次搜索当前链表的中间节点，而递归的次数和二分相同，所以时间复杂度为O(nlog(n))
- 递归次数为log(n)，所以空间复杂度为O(log(n))









思路2:

- 之前的方法中，我们每次调用都需要遍历获取中间节点，但其实不用
- 我们只需要遍历一次获取节点长度后，就可以获取到中间值了
- 之后每次调用都将中间值的左右相邻值传入作为新的边界即可



复杂度2:

- 我们免去了每次递归都遍历的操作，所以最终时间复杂度为O(n)
- 递归调用的次数不变，所以空间复杂度为O(log(n))

<hr>















# 30、判断BST的后续遍历数组

![Xnip2021-12-04_16-31-10](../Algorithem/Xnip2021-12-04_16-31-10.jpg)



![Xnip2021-12-04_16-29-47](../Algorithem/Xnip2021-12-04_16-29-47.jpg)

题意:

给你一个二叉搜索树后续遍历的数组，请你判断该数组是否正确







思路:

- 首先，后续遍历的顺序为左-右-中，所以数组中最后一个数一定为根节点
- 作为二叉搜索树，左子树的节点一定都小于根节点
- 那么我们假设左子树成立，那么剩余的数字(左子树节点右边的数)除了根节点本身外，都应该大于根节点了
- 所以我们只需要先获取到最后一位大于根节点的数字，获取其后面一位索引
- 从该索引出发后，所有的节点都应该小于根节点，否则说明该数组不正确
- 最后用同样的方法传入我们之前获取到的左右子树分界索引来判断左右子树即可



复杂度:

- 我们每次调用都遍历了当前树中所有的节点，递归调用的次数取决于树的高度，所以时间复杂度最坏为O(n^2)
- 因为递归调用的次数取决于树的高度，所以空间复杂度最坏为O(n)

<hr>













# 31、BST中的众数

![Xnip2021-12-05_10-05-02](../Algorithem/Xnip2021-12-05_10-05-02.jpg)



![Xnip2021-12-05_10-23-56](../Algorithem/Xnip2021-12-05_10-23-56.jpg)

题意:

给你一颗二叉搜索树，请你找出其中出现次数最多的节点值，并返回为数组(如果有多个则一并返回，不考虑顺序)







思路:

- 按照二叉搜索树的特性，如果我们对其进行中序遍历，则节点值相同的节点一定为相邻节点
- 所以我们只需要通过"双指针"的方式计算出重复次数，并维护一个最大的重复数即可
- 在遍历过程中，如果一个节点值的重复次数等于当前最大的重复次数，那么我们将该节点值也添加到结果集中
- 如果当前节点值的重复次数大于了最大值，那么意味着当前结果就中的数都不是最终的结果，所以需要清空集合，并将新的最大重复次数对应的节点值添加到结果集合中
- 完成遍历后，我们将这个结果集合转换为数组后返回即可



复杂度:

- 我们遍历了所有的节点，所以时间复杂度为O(n)
- 我们创建了一个集合来记录结果节点的值，所以空间复杂度为O(n)

<hr>









# 32、目标路径和

![Xnip2022-04-25_09-10-23](Binary Tree/Xnip2022-04-25_09-10-23.jpg)

<hr>









# 33、两数之和4

![Xnip2022-04-27_11-12-36](Binary Tree/Xnip2022-04-27_11-12-36.jpg)



Code:

```java
class Solution {
    Set<Integer> set = new HashSet<>();
    public boolean findTarget(TreeNode root, int k) {
        if (root == null) {
            return false;
        }

        if (!set.isEmpty()) {
            if (set.contains(k - root.val)) {
                return true;
            }
        }

        set.add(root.val);

        return findTarget(root.left, k) || findTarget(root.right, k);
    }
}
```

<hr>







# 34、BST的最近公共祖先

![Xnip2022-04-27_11-19-40](Binary Tree/Xnip2022-04-27_11-19-40.jpg)



Code:

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        TreeNode curNode = root;

        while (true) {
            if (curNode.val < p.val && curNode.val < q.val) {
                curNode = curNode.right;
            } else if (curNode.val > p.val && curNode.val > q.val) {
                curNode = curNode.left;
            } else {
                break;
            }
        }

        return curNode;
    }
}
```

<hr>









# 35、完全二叉树节点数

![Xnip2022-06-15_07-35-48](Binary Tree/Xnip2022-06-15_07-35-48.jpg)



![Xnip2022-06-15_07-34-16](Binary Tree/Xnip2022-06-15_07-34-16.jpg)



![Xnip2022-06-15_08-03-04](Binary Tree/Xnip2022-06-15_08-03-04.jpg)

题意:

给你一颗完全二叉树，请你计算出它的结点数





思路:

- 最简单的方式就是遍历所有的结点并统计即可，所以所有的遍历方法都能用，这里我选择BFS层序遍历
- 但遍历的做法其实是一种通用的方法，这里的二叉树是完全二叉树，所以还有更好的方法
- 完全二叉树要么是满二叉树，要么叶子结点那一层的结点数不满，但从子树的状态来看，总有一些部分是满二叉树
- 只要我们找出满二叉树了，就可以通过层数^2 - 1来直接计算出对应的结点数
- 所以我们只需要判断出子树中的满二叉树即可，这样就只需要计算对应的二叉树深度即可，而不是将所有的结点遍历一次





复杂度:

- 我们需要计算所有子树的深度，所以时间复杂度为O(log(n) * log(n))
- 我们在获取子树深度的时候需要通过递归来完成，栈的深度取决于树的高度，所以空间复杂度为O(log(n))

<hr>







# 36、判断平衡二叉树(不熟悉)

![Xnip2022-06-16_07-49-36](Binary Tree/Xnip2022-06-16_07-49-36.jpg)



![Xnip2022-06-16_08-01-13](Binary Tree/Xnip2022-06-16_08-01-13.jpg)

题意:
给你一棵二叉树，请你判断其是否为平衡二叉树(左右子树的高度差不超过1)





思路:

- 解题方法显而易见，只需要我们计算出对应子树的高度，然后判断高度差即可
- 获取子树高度可以单纯的使用递归，但如果是简单的从上到下递归计算的话，递归出栈的时候会有多次重复计算，时间复杂度为O(n ^ 2)
- 所以最好是通过后序遍历的方法从下到上进行计算较好



复杂度:

- 我们遍历了所有的结点，所以时间复杂度为O(n)
- 我们通过递归调用遍历了所有的结点，递归调用的栈取决于树的高度，所以空间复杂度为O(log(n))

<hr>











# 37、二叉树的所有路径(注意回溯)

![Xnip2022-06-17_08-02-52](Binary Tree/Xnip2022-06-17_08-02-52.jpg)



![Xnip2022-06-17_08-15-39](Binary Tree/Xnip2022-06-17_08-15-39.jpg)

题意:
给你一颗二叉树，请你返回所有从根结点到叶子结点的路径，并构造成规定的格式



思路:

- 从头遍历到尾，可以使用递归即DFS，也可以使用层序遍历即BFS
- 这里我们用常规的前序遍历递归写法，我们需要维护一个列表来记录每个路径对应的结点元素集
- 一旦遍历到了叶子结点，那么就需要重构为对应的字符串然后添加到结果集中去
- 需要注意的是，在遍历左右子树的时候，因为我们使用了同一个集合来记录所有的路径结点，所以在一次分支后进入另一个分支之前，我们还需要删除集合中的最后一个元素，即回溯



复杂度:

- 因为我们遍历了所有的结点，而每次递归调用都需要重新引用path路径，所以时间复杂度为O(n ^ 2)
- 我们创建了一个结果集，然而当二叉树退化为链表时，树的高度就是结点的数量，此时空间复杂度为为O(n ^ 2)

<hr>









# 38、左叶子之和(不熟悉)

![Xnip2022-06-18_10-16-59](Binary Tree/Xnip2022-06-18_10-16-59.jpg)



![Xnip2022-06-18_10-20-08](Binary Tree/Xnip2022-06-18_10-20-08.jpg)

题意:
给你一颗二叉树，请你计算出其中所有左叶子结点的结点值之和



思路:

- 该题目的难点在如何判断一个结点为左叶子结点，如果单纯的判断一个结点的左右子树为null(度为0)，则只能判断其为一个叶子结点
- 所以我们还需要通过其父结点判断其相对的位置才行，即该结点必须作为一个父结点的左结点的前提下，再判断其是否为叶子结点才行
- 明确思路后，只需要遍历所有的结点即可



复杂度:

- 我们遍历了所有的结点，所以空间复杂度为O(n)
- 我们递归调用的栈空间取决于树的高度，所以最坏时空间复杂度为O(n)

<hr>











# 39、树左下角的值

![Xnip2022-06-19_10-03-02](Binary Tree/Xnip2022-06-19_10-03-02.jpg)



![Xnip2022-06-19_10-02-11](Binary Tree/Xnip2022-06-19_10-02-11.jpg)



![Xnip2022-06-19_10-13-51](Binary Tree/Xnip2022-06-19_10-13-51.jpg)

题意:

给你一颗二叉树，请你获取其中左下角结点的值



思路:

- 这道题目用BFS无疑是最简单的了，只需要使用每层的第一个结点来覆盖结果即可，最后一个覆盖的一定是我们需要的最左下角结点值
- 如果用BFS呢？
- 这里就需要我们通过判断当前分支的深度，来判断当前分支对应的结点是否为最左下角结点了
- 让遍历到根结点的时候，如果当前分支的深度大于记录的最大深度，那么就记录下当前叶子结点的值



复杂度:

- 我们遍历了所有的结点，所以时间复杂度为O(n)
- BFS中，我们创建了一个队列来记录所有的结点，在DFS中，我们递归调用的栈空间取决于树的高度，所以空间复杂度为O(n)

<hr>









# 40、路径总和

![Xnip2022-06-20_07-42-16](Binary Tree/Xnip2022-06-20_07-42-16.jpg)

<hr>











# 










# 1、层序遍历

![Xnip2021-11-05_08-10-54](Binary Tree/Xnip2021-11-05_08-10-54.jpg)



![Xnip2021-11-05_08-39-44](Binary Tree/Xnip2021-11-05_08-39-44.jpg)



![Xnip2021-11-05_09-38-21](Binary Tree/Xnip2021-11-05_09-38-21.jpg)



![Xnip2021-11-05_08-10-21](Binary Tree/Xnip2021-11-05_08-10-21.jpg)



![Xnip2021-11-05_09-45-50](Binary Tree/Xnip2021-11-05_09-45-50.jpg)

题意:

给你一颗二叉树，请你按照层序遍历的顺序返回其中每个节点的值







思路1:

- 层序遍历的顺序其实和广度优先遍历一样(BFS)，所以我们使用BFS就行了
- 依次遍历每层的节点，并将每层节点的值保存在一个集合中，每次遍历完一层之后，就将该层集合添加到结果集合中
- 最后返回这个结果集合即可





实现1:

- 创建一个结果集合，其记录每一层的节点值集合，首先判断参数根节点是否为空，为空则直接返回这个空的结果集合
- 创建一个队列，用其记录所有的节点，且以层序遍历的方式向里面添加节点
- 首先向队列中添加根节点
- 进入循环，条件为队列不为空，创建一个集合curLevel用来记录当前层所有节点的值
- 取出当前队列的长度queueSize，只遍历queueSize次，每次取出队列头的节点
- 判断该节点的左右子节点是否为空，不为空则添加到队列中用于之后的遍历
- 注意：我们只遍历了queueSize次，该值是固定的，代表该层节点的数目，这里不能使用queue.size()，因为我们判断取出节点的左右子节点后，向该队列中添加了它的左右子节点，此时队列的长度queue.size()是变化的，无法清晰的表示该层的节点数，这样一来我们就会将所有的节点值都添加到curLevel集合中了
- 添加完左右子节点后，将该节点的值添加到当前层集合中curLevel
- 遍历完当前层所有节点后，将记录该层所有节点值的集合curLeve添加到结果集合中
- 当队列为空后，返回结果集合





复杂度1:

- 我们遍历了所有的节点，所以时间复杂度为O(n)
- 我们记录了所有的节点值，所以空间复杂度为O(n)





注意事项1:

- 在遍历当前层节点时，应该先行取出当前层的节点，而不应该直接使用queue.size()，因为在向队列添加下一层节点时，该队列的长度是变化的，此时不再代表当前层节点的数量















思路2:

- 使用深度优先遍历，根据层级将节点值添加到对应的集合中
- 每当更新到下一层级后，都将层级数 + 1





实现2:

- 创建一个全局集合，创建一个dfs方法，传入节点和层级
- 判断集合中元素的数量和层级是否相等，相等则说明该层没有记录，该节点为该层第一个节点
- 所以我们为该层创建一个集合，将节点值记录到该层集合中
- 之后向下遍历左右子节点，并增加层级数





复杂度2:

- 我们遍历了二叉树中所有的节点，所以时间复杂度为O(n)
- 我们递归调用的栈空间取决于树的高度，但我们同时还创建了一个结果集合来记录所有的节点值，所以空间复杂度为O(n)

****





















# 2、层序遍历倒序

![Xnip2021-11-06_14-29-32](../Algorithem/Xnip2021-11-06_14-29-32.jpg)



![Xnip2021-11-06_14-28-14](../Algorithem/Xnip2021-11-06_14-28-14.jpg)



![Xnip2021-11-06_14-28-37](../Algorithem/Xnip2021-11-06_14-28-37.jpg)

题意:

给你一颗二叉树，请你按照层序遍历的倒序顺序获取节点值并输出为一个二维集合





思路1:

- 根据昨天的思路，我们只需要在遍历每层节点后，将该层节点对应的集合添加到结果集合的开头即可



复杂度1:

- 同昨天





思路2:

- 使用深度优先遍历，根据层级将节点值添加到对应的集合中
- 每当更新到下一层级后，都将层级数 + 1





实现2:

- 创建一个结果集合，创建一个dfs方法，传入节点，层级和结果集合
- 判断集合中元素的数量和层级是否相等，相等则说明该层没有记录，该节点为该层第一个节点
- 所以我们为该层创建一个集合并返回到结果集合中的开头，将节点值记录到该层集合中
- 之后向下遍历左右子节点，并增加层级数



复杂度2:

- 我们遍历了所有的节点，所以时间复杂度为O(n)
- 我们创建了一个结果集合，我们递归的调用的栈空间取决于树的高度，所以空间复杂度为O(n)

****



















# 3、锯齿状层序遍历

![Xnip2021-11-07_15-45-25](../Algorithem/Xnip2021-11-07_15-45-25.jpg)



![Xnip2021-11-07_15-31-21](../Algorithem/Xnip2021-11-07_15-31-21.jpg)



![Xnip2021-11-07_15-57-33](../Algorithem/Xnip2021-11-07_15-57-33.jpg)

题意:

给你一颗二叉树，请你以锯齿状层序遍历的顺序获取其中所有的节点值，并返回一个二维集合







思路1:

- 所谓的锯齿状其实就是每层的值都根据层数的奇偶进行前后顺序的交替
- 所以我们只需要在原本层序遍历的基础上，判断一下当前的层级，如果为奇数则将当前节点值添加到当前层集合的末尾，否则添加到开头
- 我们只需要更新层数即可，其余不变



复杂度1:

- 同层序遍历，所以时空复杂度都为O(n)







思路2:

- 我们其实还可以在添加下一层元素到队列的时候作出判断
- 如果当前层为奇数，则从队列的末尾位置获取当前层的元素，并将一下层的元素都添加到队列的开头
- 否则从队列的开始位置获取当前层元素，并将下一层元素都添加到队列的末尾



复杂度2:

- 同层序遍历，所以时空复杂度都为O(n)
















# 1、反转字符串2

![Xnip2022-01-24_11-39-29](String/Xnip2022-01-24_11-39-29.jpg)



![Xnip2022-01-24_11-41-44](String/Xnip2022-01-24_11-41-44.jpg)

题意:

给你一个字符串和一个数字k，请你将每2k个字符中的前k的字符进行反转







思路:

- 按照常规思路，我们要做的其实就是两步：按照2k个字符划分每个组，反转每个组中的前k个字符
- 反转很简单，双指针就能解决，但划分组的时候需要注意: 如果最后一部分的长度不足2k，那么需要重新处理一下最后一个组对应的右索引，如果最后一组的长度都小于k了，那么此时右索引应该为char.length - 1，而不再是i + k - 1了



复杂度:

- 我们遍历了所有字符，所以时间复杂度为O(n)
- 因为Java的缘故，处理后的字符串是一个新的常量，所以空间复杂度为O(n)

<hr>













# 2、替换空格

![Xnip2022-01-25_17-44-10](String/Xnip2022-01-25_17-44-10.jpg)



![Xnip2022-01-25_17-43-52](String/Xnip2022-01-25_17-43-52.jpg)

题意:

给你一个字符串，请你将其中的空格替换为"%20"





思路:

- 我们其实可以重组字符串，遇到空格则添加"%20"，否则添加原字符即可，这里只需要遍历一次原字符串即可，当然，其实replace方法就能解决



复杂度:

- 我们遍历了一次该字符串，所以时间复杂度为O(n)
- 我们创建了一个新的字符串，所以空间复杂度为O(n)

<hr>













# 3、反转单词

![Xnip2022-01-26_09-51-29](String/Xnip2022-01-26_09-51-29.jpg)



![Xnip2022-01-26_09-53-37](String/Xnip2022-01-26_09-53-37.jpg)

题意:

给你一个字符串，请你将其中每个单词的每个字符都进行反转，单词整体所在的位置不变(字符串前后的空格需要去除，单词之间重复的空格只保留一个)



思路:

- 因为只需要反转对应单词内的字符，所以我们只需要找到对应的单词，然后倒序添加其中的字符即可
- 但寻找单词前必须要去除先后多余的空格，因此，我们需要两个指针分别从左右往中间遍历，跳过前后的空格
- 之后，创建一个活动的指针，从右边开始，直到活动指针指向的字符为空格(活动指针到右边界即为我们的单词)，将该范围内的字符倒序添加到结果字符中
- 再次使用活动指针遍历，将其中的重复空格以一个空格代替，并将活动指针移动到下一个单词的开头，并重置右边界



复杂度:

- 我们遍历了整个字符串，所以时间复杂度为O(n)
- 我们创建了一个新的结果字符串，所以空间复杂度为O(n)

<hr>













# 4、左旋转字符串

![Xnip2022-01-27_14-40-56](String/Xnip2022-01-27_14-40-56.jpg)



![Xnip2022-01-27_14-49-42](String/Xnip2022-01-27_14-49-42.jpg)

题意:

给你一个字符串，一个数字n，请你将前面的n的字符移动到后面





思路:

- 最简单的方式莫过于创建一个新的字符数组，将原字符串中的字符重组
- 但我们其实可以通过原地反转的方式:
- 先反转前n个字符，再反转后面的字符，最后反转所有的字符即可



复杂度:

- 我们遍历了所有的字符，所以时间复杂度为O(n)
- 我们创建了一个新的字符数组，所以空间复杂度为O(n)

<hr>











# 5、凯撒密码加密

![Xnip2022-01-28_10-05-36](String/Xnip2022-01-28_10-05-36.jpg)



![Xnip2022-01-28_10-15-28](String/Xnip2022-01-28_10-15-28.jpg)

题意:

给你一个字符串，和一个数字key，请你将其中的所有字母都移动key个位置





思路:

- 因为每个char都通过ASCII(unicode)与数字对应，所以我们可以通过判断移动后的字符与'z'的大小关系，从而分情况更新当前字符



复杂度:

- 我们遍历了所有的字符，所以时间复杂度为O(n)
- 我们创建了一个新的字符串数组，所以空间复杂度为O(n)

<hr>









# 6、字符编码

![Xnip2022-01-29_19-21-48](String/Xnip2022-01-29_19-21-48.jpg)



![Xnip2022-01-29_19-23-40](String/Xnip2022-01-29_19-23-40.jpg)

题意:

给你一个字符串，请你按照对应的规则进行编码





思路:

- 因为我们最后返回的是字符和对应长度的数字，所以我们需要统计每个字符对应的长度，但又因为不能产生歧义，所以每9个就要独立截断编码
- 那么我们只需要比较相邻的字符，如果相同则增加长度，不同或者长度为9则截断
- 需要注意的是，如果最后一部分也是连续的，最后一部分最后不会被添加到结果中，所有我们最后还要单独添加最后一个字符



复杂度:

- 我们遍历了所有的字符，所以时间复杂度为O(n)
- 我们创建了一个新的字符串，所以空间复杂度为O(n)

<hr>











# 7、两个句子中不常见的单词

![Xnip2022-01-30_13-46-43](String/Xnip2022-01-30_13-46-43.jpg)



![Xnip2022-01-30_14-02-31](String/Xnip2022-01-30_14-02-31.jpg)

题意:

给你两个字符串，其中每个字符串都由一些以空格为间隔的单词组成，请你找出其中只在两个字符串中出现一次的单词









思路:

- 其实重点就一句话：只出现一次的单词
- 那么我们只需要统计每个单词出现的频率，再将频率为1的单词添加到结果集中再返回即可



复杂度:

- 我们遍历了两个句子中的所有单词，所以时间复杂度为O(n + m)
- 我们创建了一个HashMap来记录所有单词的频次，所以空间复杂度为O(n + m)

<hr>













# 8、无重复最长子串长度

![Xnip2022-01-31_11-55-42](String/Xnip2022-01-31_11-55-42.jpg)



![Xnip2022-01-31_11-55-13](String/Xnip2022-01-31_11-55-13.jpg)

题意:

给你一个字符串，请你找出其中最长无重复字符子串的长度



思路:

- 因为子串的字符不能重复，所以需要我们对子串进行判断
- 最容易想到的就是遍历所有的子串，用HashSet来临时存储，这样当然，可以，但遍历所有子串的时间复杂度为O(n^2)，面试的时候估计一说思路就直接速通了QAQ
- 其实我们可以不去重，只需要使用滑动窗口就行:
- 如果如果有重复字符，则更新边界到不重复的范围，且不管有没有都更新下每个字符对应的索引位置，并更新最长子串的长度
- 这样我们只需要一个HashMap，再将输入字符串遍历一次即可



复杂度:

- 我们遍历了所有的字符，所以时间复杂度为O(n)
- 我们创建了一个HashMap，其存储的字符数量取决于输入的字符串，所以时间复杂度为(n)，其实是个常数，毕竟ASCII是有限的

<hr>

















# 9、回文子串

![Xnip2022-02-01_16-00-41](String/Xnip2022-02-01_16-00-41.jpg)



![Xnip2022-02-01_16-13-57](String/Xnip2022-02-01_16-13-57.jpg)



![Xnip2022-02-01_16-08-35](String/Xnip2022-02-01_16-08-35.jpg)

题意:

给你一个字符串，请你找出该字符串中回文子串的数量



思路:

- 最简单的肯定是遍历所有子串再判断其是否为回文字符串即可，但这样做的时间复杂度为O(n^3)
- 其实我们可以通过中心拓展法，从每个子串的中心出发(有奇有偶)，判断对应子串即可
- 其中中心序号和左右边界的对应关系参照官方题解的表表格即可



复杂度:

- 我们遍历了所有的中心点，每个中心点对应的字符串都是用双指针法进行判断，所以时间复杂度为O(n^2)
- 我们并未使用额外的空间，所有空间复杂度为O(1)

<hr>













# 10、反转前缀

![Xnip2022-02-02_15-30-09](String/Xnip2022-02-02_15-30-09.jpg)



![Xnip2022-02-02_15-40-33](String/Xnip2022-02-02_15-40-33.jpg)

题意:

给你一个字符串，一个目标字符，请你尝试找出该目标字符在字符串中第一次出现的位置，并反转之前的所有字符后返回处理后的字符串





思路:

- 因为需要反转的字符范围取决于第一次出现目标字符的位置，所以我们应该先找到目标字符，这里只需要一次遍历即可，且找到后就停止循环
- 获取索引后只需要用双指针进行反转即可



复杂度:

- 我们遍历了字符串，又通过双指针对指定区域的字符进行了遍历，所以时间复杂度为O(n)
- 我们创建了一个新的字符串，所以空间复杂度为O(n)

<hr>

























# 11、最长公共前缀

![Xnip2022-02-03_15-56-38](String/Xnip2022-02-03_15-56-38.jpg)



![Xnip2022-02-03_16-04-14](String/Xnip2022-02-03_16-04-14.jpg)

题意:

给你一个字符串数组，请你找出其中最长的公共前缀字符串





思路:

- 

- 因为是公共前缀，那么就应该存在于每个字符串中，所以我们只需要将所有的字符串都拿来和第一个字符串进行比较即可，每次比较后都更新结果即可



复杂度:

- 我们遍历了所有的字符串和对应的前缀，所以时间复杂度为O(nm)，m为平均遍历的字符数
- 我们创建了多个临时的字符串，所以空间复杂度为O(n)

<hr>













# 12、括号生成

![Xnip2022-02-04_17-51-20](String/Xnip2022-02-04_17-51-20.jpg)



![Xnip2022-02-04_18-13-01](String/Xnip2022-02-04_18-13-01.jpg)

题意:

给你一个数字n，请你生成所有可能的带有n对括号的字符串，且每对都必需有效(每对都是闭合的)





思路:

- 

- 因为需要的是有效的括号，所以就有一个规律: 在生成时，左括号的数量不能小于右括号
- 这样一来我们就能进行条件分支了，即如果左右括号的数量都为n，则添加到结果集
- 如果右括号数量大于左括号，则说明当前括号无效，直接中断即可
- 在上一个条件满足的前提下，如果左括号数量不足则优先添加左括号，反之则添加右括号



复杂度:

- 我们需要用dfs的方式遍历一颗满二叉树，其节点与n有关，这里粗略算做O(n)
- 我们需要递归调用的栈空间则取决于树的高度，大致为O(log(n))

<hr>

















# 13、正则匹配

![Xnip2022-02-05_15-48-49](String/Xnip2022-02-05_15-48-49.jpg)



![Xnip2022-02-05_16-07-00](String/Xnip2022-02-05_16-07-00.jpg)

题意:

给你一个目标字符串，一个正则字符串，请你实现正则中'*'和'.'的作用，返回匹配的结果









思路:

- 

- 创建一个二维(公式)数组，记录长度为 "行 "的目标字符串和长度为 "列 "的模式字符串之间的判断。

- 先遍历正则表达式字符串，一旦当前字符串等于'*'，则更新判断结果至之前的位置(formula[0][preIdx])

-  遍历目标字符串并通过正则表达式进行匹配，一旦当前的目标字符等于当前的模式字符，则按之前的位置更新当前的结果(formula[targetIdx - 1][patternIdx - 1])

- 如果当前模式字符是星号，则将当前目标字符与前一个模式字符进行比较

- 如果前一个模式字符等于目标字符，则通过前一个位置或前一个目标字符更新当前结果(formula[targetIdx][patternIdx - 2] || formula[targetIdx - 1][patternIdx])

- 如果没有，则通过前一个位置（formula[targetIdx][patternIdx - 2]）更新当前结果。

- 最后，通过二维数组中正确的长度获得结果

    

    

    

复杂度:

- 我们遍历了该二维数组，所以时间复杂度为O(n*m)
- 我们创建了一个二维数组，所以时间复杂度为O(n*m)

<hr>















# 14、罗马数字转整数

![Xnip2022-02-06_12-14-55](String/Xnip2022-02-06_12-14-55.jpg)



![Xnip2022-02-06_12-26-00](String/Xnip2022-02-06_12-26-00.jpg)

题意:

给你一个代表罗马数字的字符串，请你将其转换为整数





思路:

- 如果只是简单的字符转数字其实很简单，但需要注意的是，如果前一个字符代表的数字小于后一个，则应该减去这个小的数字
- 所以我们需要对相邻的数字进行判断，所以需要用到两个数字，类似双指针
- 如果前一个数字小，则从结果中减去前一个数字，如果大则加上即可
- 遍历之后还需要加上忽略的最后一个数字



复杂度:

- 我们遍历了所有的字符，所以时间复杂度为O(n)
- 我们创建的变量为常数级，所以空间复杂度为O(1)

<hr>















# 15、字符串乘积

![Xnip2022-02-07_13-27-42](String/Xnip2022-02-07_13-27-42.jpg)



![Xnip2022-02-07_13-26-25](String/Xnip2022-02-07_13-26-25.jpg)

题意:

给你两个代表数字的字符串，请你返回以字符串的形式返回它们相乘的结果





思路:

- 最容易想到的就是通过API将字符转换为数字，这样做理论上可以，但题目并不允许，不然就太简单了
- 那么我们自己写一个将字符串转换为数字的不就行了？只需要取每一位累加即可
- 很可惜也不行，因为题目给出的字符串长度最长为200，这样的两个数字的乘积超过了int和long的范围，只有API能处理
- 那咋办？其实我们可以将结果作为多个单独的数字进行存储，将对应的结果位数用数组表示就行了
- 因为直接相乘的结果会超出int的范围，这里我们可以用其中一个数的某一位与另一个数相乘，记录下每次相乘的结果再相加即可，只不过这里的"相加"结果是用一个数组来记录的
- 累加的结果可以看图中测试用例的输出
- 最后我们只需要将数组中的每个元素添加到StringBuilder中作为字符串返回即可





复杂度:

- 我们在遍历第一个字符串中的每个数字时，都将第二个字符串的每个数字遍历了一次，所以时间复杂度为O(nm)
- 我们创建的记录数组长度和两个输入字符串的长度相关，所以空间复杂度为O(n+m)

<hr>



















# 16、字符是否唯一

![Xnip2022-02-08_11-59-16](String/Xnip2022-02-08_11-59-16.jpg)



![Xnip2022-02-08_11-56-19](String/Xnip2022-02-08_11-56-19.jpg)

题意:

给你一个字符串，请你判断其中的每个字符是否唯一





思路:

- 

- 解体本身很简单，用Hash、Set、字符串API等等都可以，但这样做的空间复杂度都不为O(1)
- 这里我们可以利用二进制的每个bit进行记录，如果遍历字符时，该字符对应的bit位已经被标记了(对应位为1)，那么说明该字符不唯一，直接返回false
- 因为二进制并不直观，所以这里添加了两条输出语句并配合测试用例，详情看图



复杂度:

- 我们遍历了该字符串中的所有字符，所以时间复杂度为O(n)
- 我们创建的变量数与字符串长度无关，所以空间复杂度为O(1)

<hr>













# 17、Z字形变换

![Xnip2022-02-09_16-58-37](String/Xnip2022-02-09_16-58-37.jpg)



![Xnip2022-02-09_17-06-09](String/Xnip2022-02-09_17-06-09.jpg)

题意:

给你一个字符串，和一个代表行数的数字，请你将该字符串按照给定的数组重新排列为对应行的Z形字符串，最后将重新排列的字符按照从左到右从上到下的顺序组合为一个新的字符串并返回





思路:

- 这里我们需要重排的Z字形对应的行数是一个变量，所以我们需要按照行数进行记录
- 即为每一行都创建一个对应的"记录器"，在Java里可以是StringBuilder，遍历原字符串中的字符时，将字符添加到对应行的"记录器"中即可
- 在添加到记录器的过程中，需要注意一旦到达边界则需要向反方向递增，这里我们用一个+1/-1或者一个boolean数都可以
- 最后将每一行的"记录器"都重新组合即可



复杂度:

- 我们遍历了原字符串中的每个字符，所以时间复杂度为O(n)
- 我们创建了多个记录器，记录器中字符的数量取决于原字符串，所以空间复杂度为O(n)

<hr>











# 18、版本号比较

![Xnip2022-02-10_19-53-15](String/Xnip2022-02-10_19-53-15.jpg)



![Xnip2022-02-10_20-00-00](String/Xnip2022-02-10_20-00-00.jpg)



![Xnip2022-02-10_19-52-44](String/Xnip2022-02-10_19-52-44.jpg)

题意:

给你两个表示版本的字符串，请你判断version1是否比version2更新，是则返回1，不是则-1，版本相同则返回0，忽略先导零





思路1:

- 因为需要比较的是每个点分隔开的数字部分，所以我们要做的就是分隔，再比较数字
- 这里我们直接使用split进行分隔即可，再将分隔后的字符串通过Integer.parseInt转换为进行比较数字即可



复杂度1:

- 我们遍历了两个分隔后的字符串数组，所以时间复杂度为O(n)
- 我们用两个字符串数组记录了分隔后的字符串，所以空间复杂度为O(n)





思路2:

- 因为忽略了先导零，那么我们可以看作版本号的"数字"比较，我们只需要将版本号对应位置的非"."字符转换为数字，再累加到对应位置即可
- 这里我们可以让每个数字字符都减去'0'，这样结果就是其对应的数字了(不能单纯的累加该字符对应的ASCII码值，否则就没有忽略先导零)
- 最后再比较每个部分对应的累加值即可



复杂度2:

- 我们分别遍历了两个字符串，所以时间复杂度为O(n + m)
- 我们创建的变量个数为常量级，所以空间复杂度为O(1)

<hr>





















# 19、字符串之和

![Xnip2022-02-11_16-11-41](String/Xnip2022-02-11_16-11-41.jpg)



![Xnip2022-02-11_16-11-19](String/Xnip2022-02-11_16-11-19.jpg)

题意:

给你两个代表数字的字符串，请你返回它们相加的结果字符串





思路:

- 因为是相加，我们可以用链表相加的思路进行处理，即每次获取当前位置两个数字的和
- 对10取余后作为结果和当前位置的数，且每次都更新对应的进位
- 但这里我们需要将每个进位都添加到一个StringBuilder中方便作为字符串返回，所以最后需要反转其中的数字



复杂度:

- 我们遍历的次数取决于其中最长的字符串，所以时间复杂度为O(Max(m, n))
- 我们创建了一个StringBuilder来存放结果数字字符，所以空间复杂度为O(n)

<hr>













# 20、字符串解码

![Xnip2022-02-12_14-46-19](String/Xnip2022-02-12_14-46-19.jpg)



![Xnip2022-02-12_15-10-35](String/Xnip2022-02-12_15-10-35.jpg)

题意:

给你一个编码过的字符串，请你将其解码







思路:

- 

- 如果没有类似3[a2[c]]这样的嵌套形式的话，其实会很简单，但难就难在对嵌套的处理
- 我们在遍历的时候需要先处理里面的，再处理外面的，但外面的括号是先被遍历到的，所以我们需要根据先进后出的方式来处理，这不就是栈吗？
- 所以我们需要用栈来记录不同部分的重复次数和括号内的字符串
- 每当遍历到一个左括号的时候，就记录之前的部分，并重置对应的var
- 遍历到右括号的时候，我们再将括号内的字符串与之前部分的字符串结合在一起
- 如果是数字则更新当前重复次数即可



复杂度:

- 我们遍历了一次输入的字符串，所以时间复杂度为O(n)
- 我们创建了多个StringBuilder来记录不同部分的字符串，数量取决于嵌套的数量，所以空间复杂度为O(n)

<hr>













# 21、单词反转

![Xnip2022-02-13_14-29-57](String/Xnip2022-02-13_14-29-57.jpg)



![Xnip2022-02-13_14-45-36](String/Xnip2022-02-13_14-45-36.jpg)

题意:

给你一个字符串，其中每个单词之间用一个" "隔开，请你将其中的单词中的字母进行反转，最后返回结果





思路:

- 因为每个单词需要单独反转，所以我们需要单独取出每个单词才行，这里我们利用每个单词都由一个空格隔开的特性，使用split即可
- 之后只需要判断一下单词的次序，对最后一个单词进行特殊处理即可(最后一个单词后不需要添加" ")



复杂度:

- 我们遍历了一次输入的字符串，所以时间复杂度为O(n)
- 我们创建了一个字符串数组来记录对应的字符串，所以空间复杂度为O(n)

<hr>

















# 22、KMP匹配

![Xnip2022-02-14_14-04-17](String/Xnip2022-02-14_14-04-17.jpg)



![Xnip2022-02-14_14-03-24](String/Xnip2022-02-14_14-03-24.jpg)

题意:

给你一个目标字符串，一个匹配字符串，请你返回该匹配字符串在目标字符串中第一次出现的索引位置，如无法匹配，则返回-1





思路:

- 

- 对于Java最简单的方法就是调用String类的indexOf方法，但该方法的效率并不高，翻过源码的话就会发现jdk里的写法其实就是两个for循环暴力解而已
- 但显然这样不够高效，这里我们选择字符串里大名鼎鼎的KMP算法
- 具体实现就不赘述了，原理和实现请看B站代码随想录的视频:

https://www.bilibili.com/video/BV1PD4y1o7nd





复杂度:

- 我们遍历了两个字符串，所以时间复杂度为O(n + m)
- 我们以模式字符串为基准创建了一个前缀表(next数组)，所以空间复杂度为O(m)

<hr>















# 23、重复子字符串

![Xnip2022-02-15_16-37-51](String/Xnip2022-02-15_16-37-51.jpg)



![Xnip2022-02-15_16-47-54](String/Xnip2022-02-15_16-47-54.jpg)

题意:

给你一个非空字符串，请你判断其是否可以由其子串重复多次构成





思路:

- 题目本身不难，但解法很多，这里我们依旧可以利用KMP算法中的next数组，也就是前缀表
- 这里我们为输入的字符串建立一个next数组，最后先判断一下该字符串是否存在相等前后缀，如果存在则判断该字符的长度能否被剩余部分字符串的长度整除(除去相等前后缀的长度后)
- 能被整除说明该字符串可以由子串重复多次构成



复杂度:

- 

- 我们为str创建了一个next数组，所以时间复杂度为O(n)
- 同上，空间复杂度为O(n)

<hr>











# 24、字符串二进制之和

![Xnip2022-02-16_14-10-09](String/Xnip2022-02-16_14-10-09.jpg)



![Xnip2022-02-16_14-20-32](String/Xnip2022-02-16_14-20-32.jpg)

题意:

给你两个代表二进制数的字符串，请你计算两者的和，并以二进制的形式返回





思路:

- 看起来处理二进制不是很顺手，但其实这道题目和Day202的字符串之后的解法一毛一样
- 看过那天的code的朋友可能会发现，今天的code比起那天只是改了一下进制而已



复杂度:

- 我们同步遍历了两个字符串，遍历的次数取决于长度较长的那个，所以时间复杂度为O(max(n, m))
- 我们创建了一个StringBuilder来存储最终的结果，占用的空间也取决于长度较长的那个，所以空间复杂度也为O(max(n, m))




# 1、反转字符串2

![Xnip2022-01-24_11-39-29](String/Xnip2022-01-24_11-39-29.jpg)



![Xnip2022-01-24_11-41-44](String/Xnip2022-01-24_11-41-44.jpg)

题意:

给你一个字符串和一个数字k，请你将每2k个字符中的前k的字符进行反转







思路:

- 按照常规思路，我们要做的其实就是两步：按照2k个字符划分每个组，反转每个组中的前k个字符
- 反转很简单，双指针就能解决，但划分组的时候需要注意: 如果最后一部分的长度不足2k，那么需要重新处理一下最后一个组对应的右索引，如果最后一组的长度都小于k了，那么此时右索引应该为char.length - 1，而不再是i + k - 1了



复杂度:

- 我们遍历了所有字符，所以时间复杂度为O(n)
- 因为Java的缘故，处理后的字符串是一个新的常量，所以空间复杂度为O(n)

<hr>













# 2、替换空格

![Xnip2022-01-25_17-44-10](String/Xnip2022-01-25_17-44-10.jpg)



![Xnip2022-01-25_17-43-52](String/Xnip2022-01-25_17-43-52.jpg)

题意:

给你一个字符串，请你将其中的空格替换为"%20"





思路:

- 我们其实可以重组字符串，遇到空格则添加"%20"，否则添加原字符即可，这里只需要遍历一次原字符串即可，当然，其实replace方法就能解决



复杂度:

- 我们遍历了一次该字符串，所以时间复杂度为O(n)
- 我们创建了一个新的字符串，所以空间复杂度为O(n)










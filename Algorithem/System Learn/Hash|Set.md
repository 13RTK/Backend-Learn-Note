# 1、存在重复元素

![Xnip2022-01-08_12-49-36](Hash|Set/Xnip2022-01-08_12-49-36.jpg)



![Xnip2022-01-08_12-52-46](Hash|Set/Xnip2022-01-08_12-52-46.jpg)

题意:
给你一个数组，请你判断其中是否有两个重复的数字







思路1:

- 因为是数字数组，我们可以记录下每个数字，如果有重复则返回true，因为Set是一个好的工具



复杂度1:

- 我们遍历了数字，所以时间复杂度为O(n)
- 我们用Set记录了所有的数字，所以空间复杂度为O(1)





思路2:

- 如果有重复数字的话，那么对该数组排序后，重复的数字一定是相邻的，所以我们只需要判断相邻数字是否重复即可



复杂度2:

- 我们对数字进行了一次排序，时间复杂度为O(nlog(n))
- 我们并未使用额外的空间，所以空间复杂度为O(1)

<hr>















# 2、字母异位词

![Xnip2022-01-09_15-18-49](Hash|Set/Xnip2022-01-09_15-18-49.jpg)



![Xnip2022-01-09_15-29-29](Hash|Set/Xnip2022-01-09_15-29-29.jpg)

题意:
给你两个字符串，请你判断第二个字符串是否为第一个字符串的异位词





思路:

- 因为输入的字符全为小写字母，所以我们可以用一个长度为26的数组记录下每个字母出现的次数
- 首先遍历第一个字符串获取其中每个字母出现的次数，之后遍历第二个，将对应字母次数-1即可
- 最后遍历一次该记录数组，如果其中有一个字母对应的次数大于0，则说明两者不是异位词，返回false即可



复杂度:

- 我们遍历了两个字符串，所以时间复杂度为O(n)
- 我们创建的数组长度是固定的，所以空间复杂度为O(1)

<hr>



















# 3、异位词分组

![Xnip2022-01-10_12-30-45](Hash|Set/Xnip2022-01-10_12-30-45.jpg)



![Xnip2022-01-10_12-43-04](Hash|Set/Xnip2022-01-10_12-43-04.jpg)

题意:

给你一个字符串数组，请你将其中的异位词划分到一起后，返回该划分后的结果





思路:

- 因为异位词的字母组合是相同的，所以如果我们将其进行排序的话，结果应该是相同的，所以我们通过排序的方式就能判断异位词了
- 因为所有的异位词都是根据排序后的结果来分组的，所以我们需要将排序后的结果和实际字符对应起来，这不就是Map吗？
- 所以我们只需要遍历字符串数组，每次都将其中的字符串作为数组排序，将排序后的字符串作为key即可，之后将所有对应为一个key的放入map中的value即可
- 最后只需要返回map的values即可



复杂度:

- 我们遍历了一次字符串数组，每次循环中都将当前字符串进行了排序，所以时间复杂度为O(nlog(k))，k为最大的字符串长度
- 我们创建了一个map来记录每个key对应的字符，所以空间复杂度为O(nk)

- 




# 一、斐波那契数

![Xnip2022-03-25_08-03-07](Dynamic Programming/Xnip2022-03-25_08-03-07.jpg)



![Xnip2022-03-25_08-02-26](Dynamic Programming/Xnip2022-03-25_08-02-26.jpg)

题意:

给你一个数字n，请你给出其代表的第n + 1个斐波那契数





思路:

- 动态规划第一天，来点简单的
- 该题目用递归其实很简单，很多老师也是这么教的，但需要使用栈空间，所以复杂度并不理想
- 其实我们只需要维护两个数就行了，每次都只对这两个数进行更新即可，这种保存状态的解法看起来是动态规划，但其实更多的是滑动窗口



复杂度:

- 我们需要更新n - 1次，所以时间复杂度为O(n)
- 我们创建的变量数为常量级，所以空间复杂度为O(1)

<hr>













# 二、爬楼梯

![Xnip2022-03-26_10-03-49](Dynamic Programming/Xnip2022-03-26_10-03-49.jpg)



![Xnip2022-03-26_10-02-55](Dynamic Programming/Xnip2022-03-26_10-02-55.jpg)

题意:
要求你爬到第n阶楼梯上，每次可以爬1或2阶，请问有多少种方法





思路:

- 对于除了前两阶的每个楼梯来说：爬到当前阶的方法可以是n - 1阶再爬1阶，也可以是n - 2阶再爬2阶
- 所以爬到n阶的方法 = 爬到n - 1阶 + 爬到n - 2阶
- 乍一看，这不就是斐波那契吗？那递归能解吗？能，但会超时
- 所以这里我们可以改为创建一个数组，每个元素dp[i]都代表爬到第i阶的方法
- 因为第1、2阶是固定的，所以我们应该从i = 3开始初始化，最后只需要返回dp[n]即可
- 其实我们每次只需要到达前两个台阶的方法而已，所以这里我们可以只创建一个长度为2的数组，像昨天一样用滑动窗口的方式来做



复杂度:

- 最坏时，我们遍历了n - 2次，所以时间复杂度为O(n)
- 如果是通过创建数组dp代表每个台阶的方法的话，时间复杂度为O(n)，如果是滑动窗口，则时间复杂度为O(1)

<hr>









# 三、最小花费爬楼梯

![Xnip2022-03-27_10-20-12](Dynamic Programming/Xnip2022-03-27_10-20-12.jpg)



![Xnip2022-03-27_10-29-37](Dynamic Programming/Xnip2022-03-27_10-29-37.jpg)

题意:

给你一个数组，其中每个元素代表从当前台阶向上爬所需的费用，可以从0或者1开始且每次可爬1或2阶，请你返回爬到顶部所需的最小费用



思路:

- 这里需要的注意一点: 顶部指的是最后一个台阶的下一步，而不是最后一个台阶，这里和昨天的爬台阶是不同的
- 不过方法其实都一样，爬到某个位置的开销可以是到达其前一个台阶的开销 + 前一个台阶出发的开销，也可以是前两个位置处的开销 + 前两个位置出发的开销
- 因此，我们只需要创建一个数组，初始化前面两个位置的开销即可，之后所有位置的开销均可由它们两个获得
- 最后我们只需要获取到达最后一个台阶或者前两个台阶所需开销的最小值即可



复杂度:

- 我们遍历了一次cost数组，所以时间复杂度为O(n)
- 我们创建了一个新的数组来记录到达每个位置所需的最小开销，所以空间复杂度为O(n)，当然我们，也可以选择创建一个长度为2的数组或者就在cost数组上进行修改，这样空间复杂度就降为了O(1)








# 1、两数之和

![Xnip2021-12-06_08-36-58](LinkedList/Xnip2021-12-06_08-36-58.jpg)



![Xnip2021-12-06_08-36-30](LinkedList/Xnip2021-12-06_08-36-30.jpg)

题意:

给你两个链表的头节点，将每个节点作为一个数位，请你计算出从头节点开始求和后的新链表





思路:

- 获取新链表的方式很明显就是将两个链表同步遍历，获取的值添加到一个新的链表中即可
- 但如果这两个链表长度不一样呢？这样一来其中一个链表还没遍历完，另一个链表对应的指针就已经指向null了
- 所以对应指向null的指针，我们将其判断为0并停止遍历该链表即可
- 在获取节点值的过程中，如果节点值之和大于10，那么我们还需要为下一位获取进位，并将个位作为新的节点值
- 最后，我们的进位有可能依然为1，所以我们还需要再创建一个节点来构建这个进位



复杂度:

- 我们遍历的次数取决于两链表中最长的那个，所以时间复杂度为O(max(n, m))
- 我们创建了一个新的链表，其长度取决于两链表中最长的那个，所以空间复杂度为O(max(n, m))

<hr>

















# 2、重排链表

![Xnip2021-12-07_08-10-14](LinkedList/Xnip2021-12-07_08-10-14.jpg)



![Xnip2021-12-07_08-26-35](LinkedList/Xnip2021-12-07_08-26-35.jpg)

题意:
给你一个链表，请你将其重排





思路:

- 最简单的方法就是将所有节点存储在一个数组/集合中，使用双指针从头尾开始交替连接节点即可，但这样需要使用额外的空间
- 上述方法的核心是其中一部分要从左往右，另一部分要从右往左，所以我们需要获取左右两边的头
- 又因为左右交替的节点数应该从中间划分，所以我们需要将链表从中间位置划分，也就是找中间节点
- 找中间节点使用快慢指针即可
- 划分后右边链表应该从右往左，所以应该反转右部分链表的节点才行，也就是简单的反转链表
- 最后根据这两个节点交替重排即可



复杂度:

- 我们遍历了2次链表，所以时间复杂度为O(n)
- 我们没有创建额外的空间，所以空间复杂度为O(1)

<hr>

















# 3、k个一组翻转链表

![Xnip2021-12-08_10-42-46](LinkedList/Xnip2021-12-08_10-42-46.jpg)



![Xnip2021-12-08_10-54-39](LinkedList/Xnip2021-12-08_10-54-39.jpg)

题意:
给你一个链表和一个数字k，请你将链表以每k个一组的方式进行翻转





思路:

- 最简单的方法就是每遍历一次就将对应范围的链表截断，并翻转后保存
- 最后将这些链表连接起来，但我们需要空间来保存这些翻转的链表，其实可以直接原地翻转从而省去空间
- 简单来说，我们只需要将每次翻转后的链表与其余的部分重新连接起来即可
- 为了能够重新连接，我们除了需要得到翻转后链表的头尾节点之外，我们还需要知道它前后位置其他部分与它衔接的链表节点
- 所以在翻转之前我们需要获取到它整个部分的前一个节点，以及其后面部分的开头节点
- 其实我们只需要创建两个节点后，遍历其中一个节点k次，此时该节点指向需要翻转部分的末尾节点，为了能够翻转后连接，我们还需要记录下它的下一个节点，作为下一个部分的开头节点
- 另一个节点作为先导节点(在head之前)，它的后一个节点作为翻转节点的头节点即可
- 这样翻转之后我们既知道了翻转后链表的头尾节点，也知道了其余部分与它相连的节点了，因此我们只需要在循环中维护一个先导节点和末尾节点即可



复杂度:

- 我们遍历了所有的节点，所以时间复杂度为O(n)
- 我们没有创建额外的空间，所以空间复杂度为O(1)

<hr>



























# 4、合并有序链表

![Xnip2021-12-09_07-36-09](LinkedList/Xnip2021-12-09_07-36-09.jpg)



![Xnip2021-12-09_07-56-54](LinkedList/Xnip2021-12-09_07-56-54.jpg)



![Xnip2021-12-09_07-57-06](LinkedList/Xnip2021-12-09_07-57-06.jpg)

题意:

给你两个有序链表，请将它们合并为一个有序的链表









思路:

- 首先最容易想到的就是同时遍历两个链表，比较当前节点的大小，将小节点添加到前面即可
- 最后如果两链表长度不同的话，剩余部分直接链接到末尾即可
- 但其实还可以使用递归
- 因为节点值的小的要放在前面，所以我们只需要判断第一个节点值谁小，那么结果返回的就是谁
- 剩余的部分则该头节点的剩余部分与另一个节点之间进行判断即可



复杂度:

- 两种方法中我们都遍历了所有的节点，所以时间复杂度为O(n + m)
- 第一个方法中，我们没有创建额外的空间，所以空间复杂度为O(1)
- 第二个方法中，我们递归调用的栈空间取决于节点数，所以空间复杂度为O(n + m)

<hr>



























# 5、翻转链表2

![Xnip2021-12-10_08-48-44](LinkedList/Xnip2021-12-10_08-48-44.jpg)



![Xnip2021-12-10_08-57-50](LinkedList/Xnip2021-12-10_08-57-50.jpg)

题意:

给你一个链表，两个数字，请你将两个数字所指代范围内的链表节点翻转后返回链表



思路:

- 对于链表部分翻转的思路为: 找到翻转部分链表的头尾节点，找到头节点的前一个节点，找到尾节点的后一个节点
- 翻转该部分节点后，将初始头节点的前一个节点链接到翻转后的头节点，将翻转后的尾节点链接到初始尾节点的后一个节点
- 所以我们要做的就是找出这四个节点
- 说是要找四个节点，其实只需要找两个节点即可: 翻转部分链表头节点的前一个节点和翻转部分链表尾节点的后一个节点
- 因为这两个节点再往后迭代就是我们所需要的另外两个节点了
- 找到这两个节点的方式就是通过参数中的left和right，分别迭代对应的次数即可



复杂度

- 我们最坏时需要翻转所有的节点，所以时间复杂度为O(n)
- 我们没有创建额外的空间，所以空间复杂度为O(1)

<hr>























# 6、删除倒数第n个节点

![Xnip2021-12-11_09-33-05](LinkedList/Xnip2021-12-11_09-33-05.jpg)



![Xnip2021-12-11_09-39-45](LinkedList/Xnip2021-12-11_09-39-45.jpg)

题意:

给你一个链表和一个数字n，请你产出其中倒数第n个节点





思路:

- 很明显我们需要先定位到那个需要删除节点的上一个节点，让上一个节点的next引用指向删除节点的下一个节点即可
- 想要找到上一个节点其实使用快慢指针就可以，只需要先将快指针迭代n次即可，之后再一起快慢指针迭代
- 最后快指针到达最后一个节点后，我们慢指针就指向了删除节点的上一个节点





复杂度:

- 我们遍历了所有的节点，所以时间复杂度为O(n)
- 我们创建的空间为常量级，所以空间复杂度为O(1)

<hr>















# 7、合并k个有序链表

![Xnip2021-12-12_13-14-52](LinkedList/Xnip2021-12-12_13-14-52.jpg)



![Xnip2021-12-12_13-37-25](LinkedList/Xnip2021-12-12_13-37-25.jpg)



![Xnip2021-12-12_13-37-41](LinkedList/Xnip2021-12-12_13-37-41.jpg)

题意:

给你一个链表集合，其中有多个有序链表，请你将其中所有的链表合并为一个有序链表





思路:

- 借鉴一下合并有序链表的方法:
- 我们可以每次都只合并两个链表并返回结果，再将结果与下一个链表进行合并即可
- 这样写固然简单，但很多部分的节点被多次重复访问了，所以耗时比较夸张
- 如果将这个链表数组中的所有链表看作是二叉树的节点，每次都以两个链表为一组
- 两两合并之后再与其他组合并的结果再次合并，这样就能避免很多重复了(类似归并排序)
- 所以我们要做的只是两两分组而已，使用双指针取中间值即可



复杂度:

- 递归调用的次数为log(k)，k为链表数组的长度，而每轮合并都需要2n的时间，n为最长链表的长度，所以时间复杂度为O(kn * log(k))
- 我们递归调用的栈空间为log(k)，所以时间复杂度为O(log(k))，合并的部分可以用不占用额外空间的方式

<hr>















# 8、回文链表

![Xnip2021-12-13_08-11-28](LinkedList/Xnip2021-12-13_08-11-28.jpg)



![Xnip2021-12-13_08-25-09](LinkedList/Xnip2021-12-13_08-25-09.jpg)

题意:

给你一个链表，请你判断其是否为回文链表





思路:

- 简单的解题其实很简单，我们只需要将所有节点存储到集合中再用双指针就行了
- 但这种方法需要O(n)的空间复杂度，我们想要O(1)怎么办？
- 最容易想到的就是翻转后半部分，然后同步迭代开头节点和末尾节点即可
- 需要实现这种方法需要两步:
- 首先要找到中间节点，然后再翻转后半部分即可
- 找中间节点使用快慢指针即可，而翻转链表就很常规了！



复杂度:

- 我们遍历的时间复杂度为O(n)
- 我们没有创建额外的空间，所以空间复杂度为O(1)

<hr>





















# 9、删除重复节点

![Xnip2021-12-14_09-05-12](LinkedList/Xnip2021-12-14_09-05-12.jpg)



![Xnip2021-12-14_09-03-35](LinkedList/Xnip2021-12-14_09-03-35.jpg)

题意:
给你一个链表，请你删除重复的节点并保留一个



思路:

- 因为链表是有序的，所以如果有重复值的话，重复节点应该是紧邻的，所以我们只需要判断一个节点和它的下一个节点即可
- 如果重复则将该节点的next引用设置为下一个节点的next(跳过了下一个节点)



复杂度:

- 我们遍历了所有的节点，所以时间复杂度为O(n)
- 我们没有创建额外的空间，所以空间复杂度为O(1)

<hr>

















# 10、删除重复节点2

![Xnip2021-12-15_10-41-27](LinkedList/Xnip2021-12-15_10-41-27.jpg)



![Xnip2021-12-15_10-41-01](LinkedList/Xnip2021-12-15_10-41-01.jpg)

题意:

给你一个有序链表，请你删除其中所有的重复节点，只保留其中没有重复的节点











思路:

- 同删除重复节点1一样，我们同样可以通过遍历的方式判断当前节点值与下一个节点值从而判断是否有重复节点
- 但这里需要将所有的重复节点都删除，所以不能简单的更新next引用，而且由于头节点也可能被删除，所以我们需要创建一个虚拟头节点
- 但通过迭代，我们可以将指针指向每个重复部分的最后一个节点处
- 此时我们通过一个前驱节点判断是否有重复部分：
- 遍历指针最开始在前驱节点"pre"的后面，如果有重复部分，那么遍历指针会向后迭代
- 此时我们再判断pre.next和遍历指针是否相等即可，不相等说明中间有重复节点，此时将pre.next设置为遍历指针的next即可(因为遍历指针此时指向了最后一个重复节点)
- 如果相等说明中间没有重复节点，此时正常迭代pre即可
- 不管结果如何，遍历指针后向后正常迭代
- 最后我们只需要返回虚拟头节点的下一个节点即可



复杂度:

- 

- 我们遍历了所有的节点，所以时间复杂度为O(n)
- 我们没有创建额外的空间，所以空间复杂度为O(1)








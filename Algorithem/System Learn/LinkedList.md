# 1、两数之和

![Xnip2021-12-06_08-36-58](LinkedList/Xnip2021-12-06_08-36-58.jpg)



![Xnip2021-12-06_08-36-30](LinkedList/Xnip2021-12-06_08-36-30.jpg)

题意:

给你两个链表的头节点，将每个节点作为一个数位，请你计算出从头节点开始求和后的新链表





思路:

- 获取新链表的方式很明显就是将两个链表同步遍历，获取的值添加到一个新的链表中即可
- 但如果这两个链表长度不一样呢？这样一来其中一个链表还没遍历完，另一个链表对应的指针就已经指向null了
- 所以对应指向null的指针，我们将其判断为0并停止遍历该链表即可
- 在获取节点值的过程中，如果节点值之和大于10，那么我们还需要为下一位获取进位，并将个位作为新的节点值
- 最后，我们的进位有可能依然为1，所以我们还需要再创建一个节点来构建这个进位



复杂度:

- 我们遍历的次数取决于两链表中最长的那个，所以时间复杂度为O(max(n, m))
- 我们创建了一个新的链表，其长度取决于两链表中最长的那个，所以空间复杂度为O(max(n, m))

<hr>

















# 2、重排链表

![Xnip2021-12-07_08-10-14](LinkedList/Xnip2021-12-07_08-10-14.jpg)



![Xnip2021-12-07_08-26-35](LinkedList/Xnip2021-12-07_08-26-35.jpg)

题意:
给你一个链表，请你将其重排





思路:

- 最简单的方法就是将所有节点存储在一个数组/集合中，使用双指针从头尾开始交替连接节点即可，但这样需要使用额外的空间
- 上述方法的核心是其中一部分要从左往右，另一部分要从右往左，所以我们需要获取左右两边的头
- 又因为左右交替的节点数应该从中间划分，所以我们需要将链表从中间位置划分，也就是找中间节点
- 找中间节点使用快慢指针即可
- 划分后右边链表应该从右往左，所以应该反转右部分链表的节点才行，也就是简单的反转链表
- 最后根据这两个节点交替重排即可



复杂度:

- 我们遍历了2次链表，所以时间复杂度为O(n)
- 我们没有创建额外的空间，所以空间复杂度为O(1)


















# 1、两数之和

![Xnip2021-12-06_08-36-58](LinkedList/Xnip2021-12-06_08-36-58.jpg)



![Xnip2021-12-06_08-36-30](LinkedList/Xnip2021-12-06_08-36-30.jpg)

题意:

给你两个链表的头节点，将每个节点作为一个数位，请你计算出从头节点开始求和后的新链表





思路:

- 获取新链表的方式很明显就是将两个链表同步遍历，获取的值添加到一个新的链表中即可
- 但如果这两个链表长度不一样呢？这样一来其中一个链表还没遍历完，另一个链表对应的指针就已经指向null了
- 所以对应指向null的指针，我们将其判断为0并停止遍历该链表即可
- 在获取节点值的过程中，如果节点值之和大于10，那么我们还需要为下一位获取进位，并将个位作为新的节点值
- 最后，我们的进位有可能依然为1，所以我们还需要再创建一个节点来构建这个进位



复杂度:

- 我们遍历的次数取决于两链表中最长的那个，所以时间复杂度为O(max(n, m))
- 我们创建了一个新的链表，其长度取决于两链表中最长的那个，所以空间复杂度为O(max(n, m))

<hr>

















# 2、重排链表

![Xnip2021-12-07_08-10-14](LinkedList/Xnip2021-12-07_08-10-14.jpg)



![Xnip2021-12-07_08-26-35](LinkedList/Xnip2021-12-07_08-26-35.jpg)

题意:
给你一个链表，请你将其重排





思路:

- 最简单的方法就是将所有节点存储在一个数组/集合中，使用双指针从头尾开始交替连接节点即可，但这样需要使用额外的空间
- 上述方法的核心是其中一部分要从左往右，另一部分要从右往左，所以我们需要获取左右两边的头
- 又因为左右交替的节点数应该从中间划分，所以我们需要将链表从中间位置划分，也就是找中间节点
- 找中间节点使用快慢指针即可
- 划分后右边链表应该从右往左，所以应该反转右部分链表的节点才行，也就是简单的反转链表
- 最后根据这两个节点交替重排即可



复杂度:

- 我们遍历了2次链表，所以时间复杂度为O(n)
- 我们没有创建额外的空间，所以空间复杂度为O(1)

<hr>

















# 3、k个一组翻转链表

![Xnip2021-12-08_10-42-46](LinkedList/Xnip2021-12-08_10-42-46.jpg)



![Xnip2021-12-08_10-54-39](LinkedList/Xnip2021-12-08_10-54-39.jpg)

题意:
给你一个链表和一个数字k，请你将链表以每k个一组的方式进行翻转





思路:

- 最简单的方法就是每遍历一次就将对应范围的链表截断，并翻转后保存
- 最后将这些链表连接起来，但我们需要空间来保存这些翻转的链表，其实可以直接原地翻转从而省去空间
- 简单来说，我们只需要将每次翻转后的链表与其余的部分重新连接起来即可
- 为了能够重新连接，我们除了需要得到翻转后链表的头尾节点之外，我们还需要知道它前后位置其他部分与它衔接的链表节点
- 所以在翻转之前我们需要获取到它整个部分的前一个节点，以及其后面部分的开头节点
- 其实我们只需要创建两个节点后，遍历其中一个节点k次，此时该节点指向需要翻转部分的末尾节点，为了能够翻转后连接，我们还需要记录下它的下一个节点，作为下一个部分的开头节点
- 另一个节点作为先导节点(在head之前)，它的后一个节点作为翻转节点的头节点即可
- 这样翻转之后我们既知道了翻转后链表的头尾节点，也知道了其余部分与它相连的节点了，因此我们只需要在循环中维护一个先导节点和末尾节点即可



复杂度:

- 我们遍历了所有的节点，所以时间复杂度为O(n)
- 我们没有创建额外的空间，所以空间复杂度为O(1)


















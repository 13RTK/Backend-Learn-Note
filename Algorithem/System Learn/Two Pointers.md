# 一、轮转数组

![Xnip2022-04-01_08-54-45](Two Pointers/Xnip2022-04-01_08-54-45.jpg)



![Xnip2022-04-01_08-53-01](Two Pointers/Xnip2022-04-01_08-53-01.jpg)

题意:

给你一个数组，一个数字k，请你将该数组向右轮转k次(即所有元素向右移动k次)



思路:

- 首先需要注意一点：k有可能大于输入数组的长度，此时k次旋转和旋转k对num.length取余得到的次数是相同的(例如: 数组长度为2，右移3次和右移1次是等效的)
- 最简单的方法就是创建一个新的数组，将对应范围内的元素重写写入到新数组即可
- 但这样做需要额外的空间
- 其实我们可以使用反转来解决：
- 首先反转整个数组，然后反转前k个元素，这样移动的k个元素就解决了，之后再反转剩下的元素即可



复杂度:

- 我们将该数组遍历了两次，所以时间复杂度为O(n)
- 我们在原数组上进行了修改，所以空间复杂度为O(1)

<hr>













# 二、移动零

![Xnip2022-04-02_07-58-32](Two Pointers/Xnip2022-04-02_07-58-32.jpg)



![Xnip2022-04-02_08-28-13](Two Pointers/Xnip2022-04-02_08-28-13.jpg)

题意:

给你一个数组，请你将其中的零全部移动到后面



思路:

- 最简单的方法肯定是新建一个数组来做，但这样就没难度了
- 其实我们可以先记录下非零的数字，并将它们全部移动到前面，最后将剩余部分的元素都设置为0即可



复杂度:

- 我们遍历了两次数组，所以时间复杂度为O(n)
- 我们创建的变量个数为常量级，所以空间复杂度为O(1)









![Xnip2022-04-02_08-12-30](Two Pointers/Xnip2022-04-02_08-12-30.jpg)



![Xnip2022-04-02_08-25-51](Two Pointers/Xnip2022-04-02_08-25-51.jpg)

题意:

给你一个数组，一个目标数字，请你返回其中和为目标数的两个元素对应的索引值(从1开始)





思路:

- 乍一看和经典的两数之和差不多，但这里的数字其实是排好序的
- 既然如此，用二分法？可以，但时间复杂度为O(nlog(n))
- 其实这里用简单的双指针就行了



复杂度:

- 我们遍历了一次输入数组，所以时间复杂度为O(n)
- 我们创建的变量个数为常量级，所以空间复杂度为O(1)

<hr>











# 三、反转字符串里的单词

![Xnip2022-04-03_08-20-36](Two Pointers/Xnip2022-04-03_08-20-36.jpg)



![Xnip2022-04-03_08-27-36](Two Pointers/Xnip2022-04-03_08-27-36.jpg)

题意:

给你一个字符串，请你反转其中每个单词里的字符





思路:

- 在Java里，最简单的方法就是将每个单词存入一个StringBuilder中直接调用reverse方法后再拼接即可
- 如果不用reverse方法呢？
- 其实我们只需要自己写一个reverse方法就行了，只不过在处理单词与单词之间的空格时需要注意一下即可



复杂度:

- 我们遍历了字符串中所有的字符，所以时间复杂度为O(n)
- 我们创建了一个新的字符串，所以空间复杂度为O(n)

<hr>













# 四、链表中间节点

![Xnip2022-04-04_09-08-30](Two Pointers/Xnip2022-04-04_09-08-30.jpg)



![Xnip2022-04-04_09-12-03](Two Pointers/Xnip2022-04-04_09-12-03.jpg)

<hr>













# 五、删除倒数第n个节点

![Xnip2022-04-04_09-15-22](Two Pointers/Xnip2022-04-04_09-15-22.jpg)



![Xnip2022-04-04_09-23-43](Two Pointers/Xnip2022-04-04_09-23-43.jpg)

题意:

给你一个链表，一个数字n，请你删除倒数第n个节点



思路:

- 

- 经常做的老铁应该很快就能想到：要么用栈，要么用双指针
- 如果要用双指针的话，注意一定要创建一个虚拟的头节点才行
- 不然一旦删除的是头节点的话，最后就没法返回了



复杂度:

- 我们需要遍历一次链表，所以时间复杂度为O(n)
- 我们创建的变量个数为常量级，所以空间复杂度为O(1)

<hr>









# 六、接雨水

![Xnip2022-05-17_07-47-21](Monotonic Stack/Xnip2022-05-17_07-47-21.jpg)



![Xnip2022-05-17_08-08-36](Two Pointers/Xnip2022-05-17_08-08-36.jpg)

<hr>









# 七、三数之和

![Xnip2022-05-28_10-02-45](Two Pointers/Xnip2022-05-28_10-02-45.jpg)



![Xnip2022-05-28_10-01-23](Two Pointers/Xnip2022-05-28_10-01-23.jpg)



![Xnip2022-05-28_10-01-44](Two Pointers/Xnip2022-05-28_10-01-44.jpg)

题意:

给你一个数组，请你获取其中和值为0的所有不重复的三元组





思路:

- 该题目其实就是在两数之和的基础上添加了第三个数而已，而且这里我们只需要目标数，并不需要目标索引
- 其实只需要将一个数固定，然后寻找剩下的两个数即可
- 因为这里只需要数，不需要索引，所以我们可以对数组进行排序，这样就可以根据和值的大小关系来调整我们搜索的方向了
- 为了去重，我们在一个区间内搜索的时候，需要确保左右边界对应的数值是不重复的



复杂度:

- 我们通过两个嵌套的循环遍历了整个数组，所以时间复杂度为O(n ^ 2)
- 我们创建了一个列表来记录所有的元祖，所以空间复杂度为O(n)

<hr>











# 八、四数之和(小问题)

![Xnip2022-01-18_14-12-39](Two Pointers/Xnip2022-01-18_14-12-39.jpg)



![Xnip2022-05-29_11-32-02](Two Pointers/Xnip2022-05-29_11-32-02.jpg)



![Xnip2022-05-29_11-32-09](Two Pointers/Xnip2022-05-29_11-32-09.jpg)



![Xnip2022-05-29_11-32-16](Two Pointers/Xnip2022-05-29_11-32-16.jpg)

题意:

给你一个数组，一个目标数，请你找出所有和为目标数的四元组





思路:

- 借鉴一下昨天三数之和的做法，我们同样可以基于双指针来解决，只不过从昨天的固定一个数变为了固定两个数而已，其余不变



复杂度:

- 我们通过两个for循环固定了两个数，剩下的两个数则通过双指针一次遍历获得，所以时间复杂度为O(n ^ 3)
- 我们创建了一个结果列表来记录对应的四元组，所以空间复杂度为O(n)

<hr>









# 九、盛最多水的容器

![Xnip2022-05-29_16-31-12](Two Pointers/Xnip2022-05-29_16-31-12.jpg)



![Xnip2022-05-29_16-30-00](Two Pointers/Xnip2022-05-29_16-30-00.jpg)



![Xnip2022-05-29_16-30-08](Two Pointers/Xnip2022-05-29_16-30-08.jpg)

<hr>











# 十、移除元素(不熟练)

![Xnip2022-06-05_11-28-18](Two Pointers/Xnip2022-06-05_11-28-18.jpg)



![Xnip2022-06-05_11-30-03](Two Pointers/Xnip2022-06-05_11-30-03.jpg)




















# 一、线性表



## 1. 定义

> 线性表: 0个或多个数据元素的优先序列



- 序列，说明元素之间有顺序，如果元素有多个，则第一个元素无前驱，最后一个无后继；其余元素都是有且只有一个前驱和后继
- 线性表是有限的
- 线性表中元素的个数n，就是线性表的长度，n=0时，线性表称为空表

<hr>





## 2. 线性表的抽象数据类型

线性表的操作:

- 重置为空
- 根据位序得到元素
- 在某位置加入元素、删除元素



其余复杂操作均可由上述这些基本操作组合而来

<hr>











## 3. 顺序存储结构





### 1) 定义

> 用一段地址连续/物理连续的存储单元依次存储线性表的元素

<hr>







### 2) 存储方式

- 通过一维数组即可实现顺序存储结构



描述顺序存储结构的三个属性:

- 起始存储位置: 数组data
- 线性表的最大存储容量: 数组长度MaxSize
- 当前长度: length

<hr>







### 3) 数据长度与线性表长度区别

- 线性表的长度: 表中元素的个数
- 数组长度: 存储空间的长度

线性表的长度应该小于等于数组的长度

<hr>











### 4) 地址计算方法

> 存储器中的每个存储单元都有自己的编号，该编号为地址



对于第i个数据元素ai的存储位置可以由a1推算出来:

```
location(ai) = location(a1) + (i - 1) * cellar
```



在任何位置存入/取出数据对计算机来说都是相等的时间，是一个常数

> 它的存取时间性能为O(1)
>
> 具有这个特点的存储结构称为随机存取结构

<hr>









## 4. 顺序存储结构的插入和删除





### 1) 获取元素操作

- 将线性表中第i个位置处的元素返回:
    - 只要对应的数值i合法(在范围内)，将数组下标为i - 1下标的值返回即可



Code:

```java
public int getElement(int order) {
  if (this.length == 0 || order < 1 || order > this.length) {
    return -1;
  }

  return this.linearArray[order - 1];
}
```

<hr>







### 2) 插入操作

- 插入位置不合理，则抛出异常
- 如果线性表长度大于等于数组长度，则抛出异常或动态增加容量
- 将插入位置之后的元素都向后移动一个位置
- 将元素插入位置i处
- 表长 + 1



Code:

```java
public void insertElement(int index, int value) throws ArrayIndexOutOfBoundsException {
  if (this.length >= ARRAY_LENGTH || index < 1) {
    throw new ArrayIndexOutOfBoundsException();
  }

  for (int idx = this.length - 1; idx >= index - 1; idx--) {
    this.linearArray[idx + 1] = this.linearArray[idx];
  }

  this.linearArray[index - 1] = value;
  this.length++;
}
```

<hr>









### 3) 删除

- 删除位置不合法，抛出异常
- 取出删除元素
- 将之后的元素都向前移一位
- 表长减一

Code:

```java
public void deleteElement(int index) throws ArrayIndexOutOfBoundsException {
  if (this.length == 0 || index < 1 || index > this.length) {
    throw new ArrayIndexOutOfBoundsException();
  }

  for (int idx = index; idx <= this.length; idx++) {
    this.linearArray[idx - 1] = this.linearArray[idx];
  }

  this.length--;
}
```

<hr>











### 4) 顺序存储结构的优缺点

优点: 

- 物理存储空间直接表示逻辑关系
- 可以快速存取表中任意一个位置的元素



缺点:

- 插入和删除操作需要移动大量元素
- 长度变化较大，难以确定具体分配的存储空间
- 容易造成存储"碎片"

<hr>









## 5. 链式存储结构







### 1) 定义

- 一组存储单元可以存在内存中未被占用的任何位置
- 每个数据元素处理存储数据元素信息外，还要存储它的后继元素的**存储地址**



> 存储数据元素信息的域称为数据域，把存储后继位置的域称为指针域
>
> 指针域中存储的信息称为指针或链

- 这两部分信息组成每个数据元素，结合起来称为结点(node)
- n个结点链结成一个链表，即为线性表的链式存储结构



> 因为每个链表的每个结点中包含一个指针域，所以称为单链表



- 链表中的**第一个结点的存储位置叫做头指针**，线性链表中的最后一个结点指针为"空"
- 单链表的**第一个结点前附设的结点称为头结点**

<hr>









### 2) 头指针/头结点的异同

头指针: 

- **链表指向第一个结点的指针**，如果链表有头结点，则是指向头结点的指针
- 无论链表是否为空，头指针是链表的必要元素



头结点:

- 头结点放在第一个元素的结点之前，数据域无意义
- 头结点不一定是链表必须的要素

<hr>









### 3) 线性表链式存储Code

- 结点(Node)由存放数据元素的数据域和存放后继结点地址的指针域组成



Code:

```java
public class Node {
    int val;
    Node next;

    public Node(int val) {
        this.val = val;
    }

    public Node(int val, Node next) {
        this.val = val;
        this.next = next;
    }   
}
```

<hr>











## 6. 单链表的读取

获取链表第i个数据的思路:

1. 声明一个结点p指向第一个结点，初始化j从1开始
2. 当j < i，遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1
3. 如果链表末尾p为空，说明i个元素不存在
4. 查找成功会直接返回p的数据



Code:

```java
public static int getElement(int index, Node head) throws ArrayIndexOutOfBoundsException {
  Node curNode = head;

  int curOrder = 1;
  while (curNode != null && curOrder < index) {
    curNode = curNode.next;
    curOrder++;
  }

  if (curNode == null || curOrder > index) {
    throw new ArrayIndexOutOfBoundsException();
  }

  return curNode.val;
}
```

<hr>











## 7. 单链表的插入与删除



### 1) 单链表的插入



思路:

1. 声明一个指向链表一个结点的结点p，初始化计数器从1开始
2. 当计数器 < 目标次序，就让结点p的指针向后移动一位，计数器累加1
3. 如果链表末尾p为空，则说明第index个元素不存在
4. 如果查找成功则生成一个空结点newNode
5. 给newNode赋值
6. 将结点插入newNode.next = p.next, p.next = newNode



Code:

```java
```


























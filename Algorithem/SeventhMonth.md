# Day61

## Tag: Array, Dimensional-array

![Xnip2021-09-22_07-10-58](Algorithem/Xnip2021-09-22_07-10-58.jpg)



![Xnip2021-09-22_07-10-38](Algorithem/Xnip2021-09-22_07-10-38.jpg)

题意:

给你一个二维数组，其每列每行都是排序好的，再给你一个目标值，请你在这个二维数组中找到该目标值，并返回其对应的索引





思路:

- 观察二维数组可得知: 该二维数组从左上到右下，数值依次增大，但如果从左上角开始找的话，同时更新行和列可能会跳过我们的目标
- 所以，为了能单独控制大小，我们需要从右上角开始
- 因为每一个列也是排序过的，所以如果该列的第一个数就大于目标值，则说明该列所有值都大于目标值，所以更新该列
- 如果当前位置值小于目标值，那么在垂直位置上，目标值应该在下方，所以更新行



实现(Java):

- 从右上角开始，初始化对应的行列索引
- 进入循环，条件为索引不越界
- 判断当前值与目标值的大小，相等则直接返回索引
- 小于则更新行值，大于则更新列值



复杂度:

- 最坏的情况下，我们会遍历行和列中所有的数字，所以共消耗r+c，时间复杂度为O(r+c)
- 我们创建的变量为常量级，所以空间复杂度为O(1)

****

















# Day62

## Tag: Array, Binary search

![Xnip2021-09-23_07-30-02](Algorithem/Xnip2021-09-23_07-30-02.jpg)



![Xnip2021-09-23_07-36-20](Algorithem/Xnip2021-09-23_07-36-20.jpg)

题意:

给你一个旋转过的数组，和一个目标值请你使用二分查找找出其在该数组中对应的索引





思路:

- 虽然该数组在旋转后就不是严格的排序数组了，但从旋转的位置开始，其左右两个部分都是有序的，同样能够使用二分查找
- 所以我们只需要判断该目标数在左边还是右边即可



实现(Java):

- 我们同样对该数组取中位数，比较中位数与边界值，判断中位数所处的位置
- 将目标值与中位数和边界值比较，确定目标值所处的区间，更新边界值到对应的区间中



复杂度:

- 我们通过二分查找的方式找到了目标值，所以时间复杂度为O(log(n))
- 我们创建的变量个数为常量级，所以空间复杂度为O(1)

****

















# Day63

## Tag: Binary Search, Array

![Xnip2021-09-24_09-49-34](Algorithem/Xnip2021-09-24_09-49-34.jpg)



![Xnip2021-09-24_09-43-55](Algorithem/Xnip2021-09-24_09-43-55.jpg)



![Xnip2021-09-24_09-53-36](Algorithem/Xnip2021-09-24_09-53-36.jpg)

题意:

给你一个排序后的数组，其中有重复的数字，再给你一个目标值，请你找出该目标值在数组中出现范围的起始和结束索引





思路:

- 所谓的起始和结束位置其实就是第一次出现和最后一次出现罢了，所以我们只需要从0开始正向遍历就能找到开始位置的索引
- 从末尾位置开始反向遍历就能找到结束位置的索引，两个循环就能搞定，时间复杂度为O(n)，空间复杂度为O(1)
- 但既然是排序后的数组，能不能用二分法呢？当然可以
- 在这道题目中，比起传统二分法不同的自然是目标数字不止出现一次，所以通过二分法找到目标数组后，我们还需要判断其是否在最左/右的位置上，如果不在，则仍旧需要更新边界





实现(Java):

- 创建一个方法，其接受原方法的参数外，还接受一个boolean类型来判断当前调用是寻找左还是右边界
- 进入传统的二分法步骤，判断中间索引值是否等于目标值
- 如果等于，则进行附加判断:
- 首先判断boolean类型，获取此次调用的目的
- 如果是获取左边界，则判断当前中位数索引是否等于0，或者中位索引前一个位置的数是否为目标值
- 如果当前中位索引为0，或者前一位不为目标值，则说明当前中位索引为左边界，将其记录
- 如果是获取右边界，则仅修改判断为中位索引是否为最后一个索引值(array.length - 1)，其余与左边界相同
- 通过两种boolean值，我们就获取了左右边界索引





复杂度:

- 我们在搜寻时使用了二分法，所以时间复杂度优化到了O(log(n))
- 我们创建的变量个数为常量级，所以空间复杂度为O(1)

****

















# Day64

## Tag: 

![Xnip2021-09-25_07-38-22](Algorithem/Xnip2021-09-25_07-38-22.jpg)



![Xnip2021-09-25_07-48-10](Algorithem/Xnip2021-09-25_07-48-10.jpg)

题意:

给你一个没有重复数字的随机数组，再给你一个数字k，请你找出该数组中第k个最小的元素





思路:

- 首先最容易想到的肯定是先排序，之后直接返回对应索引的值即可，但时间复杂度为O(nlog(n))
- 能不能优化至O(n)? 其实这个问题同Algorithm Day60的解决思路是一样一样的，只不过那道题目的k是个常数(3)，且求的是最大值罢了
- 在那道题目中，我们创建一个长度为3的数组，通过动态更新它来获取了最大的三个数
- 在这道题目里，我们只需要将3换做k，将正序更新换成逆序更新即可，其余不变

****















# Day65

## Tag: Array, Binary Search

![Xnip2021-09-26_07-10-52](Algorithem/Xnip2021-09-26_07-10-52.jpg)



![Xnip2021-09-26_07-14-06](Algorithem/Xnip2021-09-26_07-14-06.jpg)



![Xnip2021-09-26_07-19-59](Algorithem/Xnip2021-09-26_07-19-59.jpg)

题意:

给你个排序后无重复数字的数组，请你查出其中最小的索引值，其对应位置的元素值与索引值相同





思路:

- 最简单的方法肯定是直接遍历一遍，比较每个值和其索引值即可，这样做的时间复杂度为O(n)，但我们其实能用二分法
- 比起简单的用二分法寻找目标数，这里我们还需要在找到后判断其是否最小，转换一下即判断它是否在最左边或者其前一个位置是否小于索引
- 处于最左边很好理解，因为其如果在最左边，则其毫无疑问是最小的，但后一个条件呢？
- 因为这个数组是排序后的，所以如果在我们找到的索引位置的后一个位置上，该索引大于其对应的值，那么之后的值也会是这种关系
- 这样一来，我们找到的数就是最小的符合条件的值了





实现(Java):

- 创建两个指针，获取中间索引位置
- 判断中间索引和其对应值的大小关系
- 如果不等则更新对应的边界
- 如果相等则判断其是否在最左边或者其前一个位置的索引和对应值的大小关系，满足则返回索引



复杂度:

- 我们使用了二分法，所以时间复杂度比起最简单的方法优化至了O(log(n))
- 我们使用的变量个数为常量级，所以空间复杂度为O(1)

****

















# Day66

## Tag: Bubble Sort

![Xnip2021-09-27_06-59-59](Algorithem/Xnip2021-09-27_06-59-59.jpg)



![Xnip2021-09-27_07-06-48](Algorithem/Xnip2021-09-27_07-06-48.jpg)

题意:

给你一个数组，请你使用冒泡排序的方式将该数组排序







思路:

- 调用API肯定是最简单的，但这里要求用冒泡，那就老老实实写个呗
- 冒泡其实就是让每个数都和临近的数相比，不符合排序的顺序则交换两个数的位置





实现(Java):

- 设置一个计数器，其计算排序操作的次数，因为每次排序后最大的数会被排在最后，以便之后的排序跳过最后排序过的数字
- 设置一个boolean变量，其作为是否继续排序的依据
- 进入循环，初始化boolean变量为true，判断当前数字和下一个数字的大小关系，如果不同则交换，并将boolean变量设置为false
- 只要boolean变量不为true，则继续循环



复杂度:

- 最坏时我们需要将该数组遍历近n^2，所以时间复杂度为O(n^2)
- 我们创建的变量个数为常量级，所以空间复杂度为O(1)

****















# Day67

## Tag: Insertion Sort

![Xnip2021-09-28_07-06-00](Algorithem/Xnip2021-09-28_07-06-00.jpg)



![Xnip2021-09-28_07-11-44](Algorithem/Xnip2021-09-28_07-11-44.jpg)

题意:

给你一个数组，请你使用插入排序的方法将其排序





思路:

- 同冒泡排序不同的是，插入排序需要从后往前比较，之后再交换，比较时是当前数与前一个数进行比较





复杂度:

- 在遍历该数组时，我们还会将数组从当前位置往前遍历，最坏需要n^2，所以时间复杂度为O(n^2)
- 我们创建的变量个数为常量级，所以空间复杂度为O(1)

****

















# Day68

## Tag: Selection Sort,  Array

![Xnip2021-09-29_07-10-02](Algorithem/Xnip2021-09-29_07-10-02.jpg)



![Xnip2021-09-29_07-16-28](Algorithem/Xnip2021-09-29_07-16-28.jpg)

题意:

给你一个数组，请你用选择排序的方法对其进行排序





思路:

- 选择排序即每次都将数组中的最小值交换到最前面来，所以我们需要对数组遍历多次，以寻找最小值，并与左边界值交换



实现(Java):

- 创建一个var用来记录左边界值，进入循环，条件为该var小于最后一个索引
- 创建一个var从左边界值开始，首先遍历一遍数组获取最小值的索引并记录在该var中
- 交换该索引对应数与左边界对应的数，更新左边界



复杂度:

- 我们将数组遍历了n^2次，所以时间复杂度为O(n^2)
- 我们创建的变量个数为常量级，所以空间复杂度为O(1)

****















# Day69

## Tag: Array, Sort

![Xnip2021-09-30_07-10-53](Algorithem/Xnip2021-09-30_07-10-53.jpg)



![Xnip2021-09-30_07-13-23](Algorithem/Xnip2021-09-30_07-13-23.jpg)

题意:

给你一个有重复数字的数组，共有3种数字，再给你一个排序数组，请你按照排序数组中的顺序，将重复数组中的数字进行排序







思路:

- 因为只有三个数字，所以我们一旦排好其中的两个，那么数组自然就排列好了
- 所以我们需要在三个数字中选两个进行排列，中间那个自然不会选，因为其索引位置不好确定
- 自然，我们先排列排序数组中的第一个数字，再排列最后一个即可





实现(Java):

- 创建两个var作为第一和最后一个数字的插入索引
- 正向遍历一遍数组，将第一个数字移动到第一个数字的插入索引处，同时更新索引
- 此时该数组前半部分已经是排列好的第一个数字了，接下来我们只需要在后面找即可
- 逆序遍历一遍数组，将最后一个数字移动到最后一个数字的插入索引处，同时更新索引
- 此时数组已经排序完成



复杂度:

- 我们遍历了两次数组，所以时间复杂度为O(n)
- 我们创建的变量个数为常量级，所以空间复杂度为O(1)

****















# Day70

## Tag: Quick Sort

![Xnip2021-10-01_09-58-43](Algorithem/Xnip2021-10-01_09-58-43.jpg)



![Xnip2021-10-01_11-02-49](Algorithem/Xnip2021-10-01_11-02-49.jpg)

题意:

给你一个数组，请你使用快速排序的方式对该数组进行排序



思路:

- 首先简述快速排序的原理:
- 随机选取一个数字(这里选择第一个数字)，以其为基准，将其余部分的数字进行简单比较
- 利用双指针从开头和结尾位置开始，如果左指针指向的数字大于基准，且右指针指向的数字小于基准，则交换两指针指向的数字
- 如果左指针或者右指针不符合条件，则更新对应的指针，直到两指针交换相对位置(left > right)
- 此时，右指针左边的值都小于基准值，左指针及右边的值都大于基准值，我们将右指针指向的值与基准值交换
- 此时我们的基准值就确定了其在数组中的位置，且将数组分成了两个部分
- 之后我们再次重复上述步骤，对剩余两部分采取相同的方式(递归调用即可)便能对整个数组进行排序





实现(Java):

- 创建一个符合递归调用的方法，传入初始数组的左右边界
- 首先定下基准值，和剩余部分的左右指针(基准值 + 1, length -1)
- 比较左右指针与基准值的大小关系，两者都符合则交换两指针指向的值，不管符不符合都更新对应边界
- 交换基准值和右指针指向的值，再递归调用本方法对剩余两部分进行排序





复杂度:

- 我们选取的基准值可以随机，方法类似二分，但每次比较都需要遍历一次数组，所以时间复杂度平均为O(nlog(n))
- 我们递归调用所需的栈空间也取决于对数组的划分，所以空间复杂度为O(log(n))

****













# Day71

## Tag: Heap Sort, Heap

![Xnip2021-10-02_21-03-24](Algorithem/Xnip2021-10-02_21-03-24.jpg)



![Xnip2021-10-02_21-03-08](Algorithem/Xnip2021-10-02_21-03-08.jpg)

题意:

给你一个数组，请你使用堆排序的方法对其进行排序





思路:

- 进行堆排序之前，我们需要先将该数组构建为堆
- 利用二叉树的性质，我们将数组左半部分的索引位置作为构建后的非叶子结点
- 这里我们构建一个大根堆(即每颗子树的根节点值为最大值)
- 构建后，我们将第一个索引位置的值与最后一个位置的值进行交换，这样我们就将最大的值排在了数组的最后
- 再通过构建的方式重构剩余的元素，使其再次称为大根堆，往复下来，数组后面部分排序的元素就越来越多，堆里的数字越来越少，直到将整个数组排序



实现(java):

- 构建大根堆的过程需要我们从底下最小的子树开始构建，所以我们需要从最小值的子树根节点开始，因此是从数组中间索引的左边位置，开始倒序遍历(这些索引值都对应构建后的根节点)
- 对于每个子树，首先利用二叉树的性质，根节点索引值 * 2 + 1 = 右子树索引值，我们都先找出左右节点中的最大值(如果左右子结点存在的话)，之后将该最大值与当前树的根节点比较，更新最大值到根节点中
- 之后判断被替换节点其下的子树，并更新根节点索引为子树索引
- 完成构建后交换第一个位置与最后一个位置的值，使得最大值排在最后得以排序
- 交换后重复之前的步骤再次重构大根堆，并再次交换
- 最后直到堆中只有一个元素，该数组完成排列



复杂度:

- 我们将该数组构建成大根堆，也就是二叉树的结构，该用时取决于二叉树的结构，根据二叉树的性质，数组被构建成二叉树后有log(n)层，又因为我们交换了n - 1次，所以时间复杂度为O(nlog(n))
- 我们创建的变量个数为常量级，所以空间复杂度为O(1)

****

















# Day72

## Tag: Min Heap, Sift Up/Down

![Xnip2021-10-03_11-02-40](Algorithem/Xnip2021-10-03_11-02-40.jpg)



![Xnip2021-10-03_11-14-24](Algorithem/Xnip2021-10-03_11-14-24.jpg)

题意:

给你编写一个MinHeap类，实现其中的各种方法







思路:

- 和昨天不同的是，我们这次构建的是小根堆，所以在siftDown中的大小判断要反过来才行，其余一致
- 而siftUp方法则是用同siftDown相反的方式，根据叶子结点的索引值反过来去找其根节点的索引值
- 其余方法则是插入/删除后用siftDown或siftUp方法进行重建即可

****













# Day73

## Tag: Radix Sort, Counting Sort

![Xnip2021-10-04_09-27-56](Algorithem/Xnip2021-10-04_09-27-56.jpg)



![Xnip2021-10-04_10-06-30](Algorithem/Xnip2021-10-04_10-06-30.jpg)

题意:

给你一个数组，请你通过基数排序的方式对其排序







思路:

- 在基数排序之前，我们需要了解一下counting sort(计数排序或统计排序)
- counting sort通过计算数组中所有元素某一位上的数出现的频率，从而获取它们对应的索引位置，从而进行排序，如:
- 数组8762, 654, 3008, 345, 87, 65, 234, 12, 2；使用counting sort对个位数排序的话，首先计算出0～9每个数字出现的频率如:
- 0:0, 1:0, 2:2, 3:0, 4:2, 5:2, 7:1, 8:1, 9:0
- 将对应位置累加，得 0:0, 1:0, 2:2, 3:2, 4:4, 5:6, 7:7, 8:8, 9:8
- 解析一下这个累加后的数组: 2:2说明个位数为2的有两个数字，又因为0，1对应的频率都为0，所以个位数为2的数字被排列在前两个位置，也就是索引为0，1的位置上，而这两个索引刚好对应频率2 - 1，1 - 1
- 所以我们遍历一次原数组，获取对应位数后从该频率数组获取相应的频率，即可获取当前数字排序后的索引值，就能通过某一位数字对所有的数排序



- 上述只演示了个位数，我们还可以依数位排序下去，直到取到最大值的位数后，所有的数就根据大小排序完成了！









实现(Java):

- 根据思路，我们需要先取得待排序数组中的最大值，以确定我们需要统计排序的次数和所取的位数
- 进入循环，调用countingSort，传入当前所取数位和数组
- 在countingSort中，创建一个长度为10的数组，用来记录每个数字的频率，再创建一个与原数组等长的数组用来存储该次排序后的结果
- 遍历一次原数组，通过数组digitCounter记录下当前数位中数字出现的频率
- 再遍历一次digitCounter，累加频率以获取每个数字在排序数组中的最后一个索引位置以便之后获取
- 反向遍历一次原数组，获取每个元素对应数位上的数字，通过它获取digitCounter上对应的索引(之后说明为什么反向遍历)
- 减去digitCounter上对应的数字，意为用掉了一个数，此时更新后的数就是对应的索引，将原数组当前的数放到sortedArr中对应索引位置处
- 完成后将sortedArr中的数复写到原数组中
- 循环调用的次数取决于最大值的位数



- 之所以在countingSort中排序原数组时不正序遍历，是因为一旦出现高位相同但低位不同的数时，这两个数无法被正确排序如:
- 原数组: 67, 68。首先对个位进行排序，结果自然是67，68，因为它们个位不同
- 之后对十位进行排序: digitCounter为:[...6:2...]
- 此时如果对原数组正序遍历，那么67就会先被放到索引1位置上(2 - 1)，之后便是68，最终结果为{68, 67}，显然不对，所以使用倒序遍历就能解决这个问题









复杂度:

- 我们每次调用countingSort都用时n，而调用的次数取决于最大值的位数d，所以时间复杂度为O(d * n)
- 我们每次调用countingSort，我们都需要创建一个sortArray来存储该次排序后的结果，所以空间复杂度为O(d * n)

****

















# Day74

## Tag: Sort, Median

![Xnip2021-10-05_10-37-15](Algorithem/Xnip2021-10-05_10-37-15.jpg)



![Xnip2021-10-05_10-36-54](Algorithem/Xnip2021-10-05_10-36-54.jpg)

题意:

请你编写ContinuousMedianHandler类中的insert方法，该方法接收一个int数字，并应该根据接收的所有int数字动态地维护更新字段median，以便getMedian能获取到最新的中间值





思路:

- 今天急着下班，直接调用API了，我们直接新增一个字段用来存储所有插入的数字，且每插入一次都将该集合重新排序
- 判断集合中元素的个数，由此判断中位数的取法(直接取中间索引还是取两个中间值的和)
- 最后更新到字段median中即可







复杂度:

- 调用API排序的时间复杂度为O(nlog(n))，当然自己手写一个堆排序或者其他的排序方式也行
- 我们动态维护了一个集合来存储并排序插入的所有元素，所以空间复杂度为O(n)

****

















# Day75

## Tag: Merge Sort

![Xnip2021-10-06_12-36-45](Algorithem/Xnip2021-10-06_12-36-45.jpg)



![Xnip2021-10-06_12-36-27](Algorithem/Xnip2021-10-06_12-36-27.jpg)

题意:

给你一个数组，请你使用归并排序的方法将其排序(mergeSort)







思路:

- 归并排序的基本思路就是分治，将数组从中间位置分离成两个子数组，直到子数组的长度为1
- 将这些长度为1的数组重新排成有序数组，直到排列完所有的数组即可



实现(Java):

- 将原方法作为递归方法，取当前数组的中位索引，以此为界将数组划分两个两个部分，直到子数组长度为1
- 划分后将所有数组重新有序的归并到一起，该步骤需要利用三个指针，其中结果数组指针要与两个合并数组中的最小值索引同步更新



复杂度:

- 我们每次都将数组分成两部分，之后又合在一起，其实与二分法差不多，二分的部分为log(n)，而合并又与n有关，所以时间复杂度为O(nlog(n))
- 我们递归调用的栈空间同二分法，但我们将所有合并的数组都存储了下来，所以空间复杂度为O(nlog(n))

****



















# Day76

## Tag: Array, Two-dimensional Sort

![Xnip2021-10-07_11-02-25](Algorithem/Xnip2021-10-07_11-02-25.jpg)



![Xnip2021-10-07_11-12-22](Algorithem/Xnip2021-10-07_11-12-22.jpg)



![50DB3A32-FD9B-423E-96A2-A28F9B70D1DF](Algorithem/50DB3A32-FD9B-423E-96A2-A28F9B70D1DF.png)

题意:

- 给你一个二维集合，其中每个元素都为的长度为2的小集合，每个小集合的开头元素表示时间的开始，结尾元素表示时间的结束，这个时间段表明一个学生想要借用笔记本电脑的时间段。两个学生不能同时使用一台笔记本，请你根据这些时间段判断至少需要准备的笔记本的数量







思路:

- 将该二维集合中所有的元素映射到一条数轴上(见图)
- 可以得知，我们需要找出最大的重叠数才行
- 又由图可知，重叠部分的时间段的开头总是相邻的，但我们获取的输入是乱序的，为了有条理的找出结果，我们可以对该输入的二维集合针对元素的第一个值进行排序
- 对于每个时间段，如果其开始的时间小于前面时间段的结尾时间，则说明该时间段的学生只能使用另外的笔记本
- 通过这种方式，我们就可以计算出每个时间段使用的笔记本数量，最后取最大值即可



实现(Java):

- 首先对该二维数组进行排序，之后从索引1位置开始遍历
- 每次将当前索引对应时间段的开头时间与之前所有时间段的结尾比较，如果小于则说明需要另外使用笔记本
- 这样将所有的时间段遍历完成后，返回所需笔记本数量的最大值即可





复杂度:

- 我们首先对该集合进行了排序，用时nlog(n)，之后又遍历了集合，所以时间复杂度为O(nlog(n))
- 我们创建的变量个数为常量级，所以空间复杂度为O(1)


















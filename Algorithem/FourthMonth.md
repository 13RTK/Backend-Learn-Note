# Day91

## Tag: BFS, Map, Queue



![Xnip2021-06-24_10-30-10](Algorithem/Xnip2021-06-24_10-30-10.jpg)



![Xnip2021-06-24_10-27-23](Algorithem/Xnip2021-06-24_10-27-23.jpg)



题意:

给你一个员工集合，和一个指定的id，返回该员工和其所有下属员工的重要性之和(下属员工包含其下属的下属)

每个员工拥有三种属性:id, importance, subordinates(前两者为int, 下属字段为一个List<Integer>集合)





思路:

- 创建一个hashmap映射，键值对分别为id，对应的员工对象，将参数集合添加到该映射表中
- 创建一个<Integer>队列，先使用参数id，通过hashmap映射获取对应的员工对象并添加到队列中
- 如果队列不为空，就进行如下循环:
- 取出并移除队列中的第一个对象，将其importance添加到result中，判断其subordinates是否为空，不为空就添加到队列尾
- 队列为空就跳出循环，返回result即可





数据结构:

队列: 存储相关的员工id，利用其先进先出的特性

图: 存储每个员工间的层次关系，进行广度优先遍历(BFS)

****













# Day92

## Tag: SQL Day37

****















# Day93

## Tag: Divide Comquer, Recursion



![Xnip2021-06-26_10-27-56](Algorithem/Xnip2021-06-26_10-27-56.jpg)



![Xnip2021-06-26_10-27-20](Algorithem/Xnip2021-06-26_10-27-20.jpg)



题意:

给你一个无序链表的头节点，请你将其重写排列为有序链表，并返回排序后的头节点





思路:

- 此题目可以暴力解:即遍历一次链表后将值最小的添加到新的链表尾，添加再将其删除并重新整理链表，这样做需要将整个链表都遍历n!次，很低效



- 想象一下: 如果链表中只有一个节点呢？是不是不用排序直接返回就行了？那么具体该怎么做呢？
- 这里可以使用分治的思想: 即将大问题分解为小问题，这道题就可以将长链表分解为一个个只有一个节点的小链表
- 为了保证划分后的两部分能同时得到小链表，我们每次划分需要从中间开始，这里我们使用快慢指针来获取中间节点
- 每次划分后，都将头节点head到中间节点midNode作为前半部分，从midNode到null作为后半部分，直到链表中只有一个节点为止(头节点的下一个节点为null)，这里明显可以使用递归，终止条件为head.next == null
- 获取小链表后，我们将两部分进行排序，从两个只有一个节点的链表开始排序后，每次排序都会是两个有序链表的合并问题(见Algorithm Day35)，只需要将两部分都遍历一次即可合并，最后返回头节点

****









# Day94

## Tag: Two Pointers, Array



![Xnip2021-06-27_13-58-26](Algorithem/Xnip2021-06-27_13-58-26.jpg)



![Xnip2021-06-27_13-57-57](Algorithem/Xnip2021-06-27_13-57-57.jpg)





题意:

给你一个数组和一个目标值，返回最接近目标值的三个数的和





思路:

- 思路其实和Algorithm Day73中的差不多，只不过返回的是值罢了
- 同理，为了方便一次遍历就能对比，我们首先对参数数组进行排序
- 将数组进行一次遍历，遍历时使用的索引值作为第一个数字的索引
- 将第二个数字的索引值初始化为第一个数字的后一位，第三个数字的索引值初始化为数组的最后一位
- 接下来将寻找最合适的第二三个数字，将它们的索引作为左右边界，该问题就转换为了二分法！
- 首先如果目前三个数字的和就是目标值，那么直接返回，不是则进行下面的步骤
- 如果目前三个数字的和离目标值的距离(通过差值的绝对值)，比当前的最小距离还小(minDVal)，则更新最小距离，并更新结果值
- 接下来进行二分法的传统做法: 如果当前的和小于目标值，则更新左边界(即第二个数字的值)，否则就更新右边(第三个数字的值)
- 将数组遍历一次后便可返回结果


















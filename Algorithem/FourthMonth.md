# Day91

## Tag: BFS, Map, Queue



![Xnip2021-06-24_10-30-10](Algorithem/Xnip2021-06-24_10-30-10.jpg)



![Xnip2021-06-24_10-27-23](Algorithem/Xnip2021-06-24_10-27-23.jpg)



题意:

给你一个员工集合，和一个指定的id，返回该员工和其所有下属员工的重要性之和(下属员工包含其下属的下属)

每个员工拥有三种属性:id, importance, subordinates(前两者为int, 下属字段为一个List<Integer>集合)





思路:

- 创建一个hashmap映射，键值对分别为id，对应的员工对象，将参数集合添加到该映射表中
- 创建一个<Integer>队列，先使用参数id，通过hashmap映射获取对应的员工对象并添加到队列中
- 如果队列不为空，就进行如下循环:
- 取出并移除队列中的第一个对象，将其importance添加到result中，判断其subordinates是否为空，不为空就添加到队列尾
- 队列为空就跳出循环，返回result即可





数据结构:

队列: 存储相关的员工id，利用其先进先出的特性

图: 存储每个员工间的层次关系，进行广度优先遍历(BFS)

****













# Day92

## Tag: SQL Day37

****















# Day93

## Tag: Divide Comquer, Recursion



![Xnip2021-06-26_10-27-56](Algorithem/Xnip2021-06-26_10-27-56.jpg)



![Xnip2021-06-26_10-27-20](Algorithem/Xnip2021-06-26_10-27-20.jpg)



题意:

给你一个无序链表的头节点，请你将其重写排列为有序链表，并返回排序后的头节点





思路:

- 此题目可以暴力解:即遍历一次链表后将值最小的添加到新的链表尾，添加再将其删除并重新整理链表，这样做需要将整个链表都遍历n!次，很低效



- 想象一下: 如果链表中只有一个节点呢？是不是不用排序直接返回就行了？那么具体该怎么做呢？
- 这里可以使用分治的思想: 即将大问题分解为小问题，这道题就可以将长链表分解为一个个只有一个节点的小链表
- 为了保证划分后的两部分能同时得到小链表，我们每次划分需要从中间开始，这里我们使用快慢指针来获取中间节点
- 每次划分后，都将头节点head到中间节点midNode作为前半部分，从midNode到null作为后半部分，直到链表中只有一个节点为止(头节点的下一个节点为null)，这里明显可以使用递归，终止条件为head.next == null
- 获取小链表后，我们将两部分进行排序，从两个只有一个节点的链表开始排序后，每次排序都会是两个有序链表的合并问题(见Algorithm Day35)，只需要将两部分都遍历一次即可合并，最后返回头节点

****









# Day94

## Tag: Two Pointers, Array



![Xnip2021-06-27_13-58-26](Algorithem/Xnip2021-06-27_13-58-26.jpg)



![Xnip2021-06-27_13-57-57](Algorithem/Xnip2021-06-27_13-57-57.jpg)





题意:

给你一个数组和一个目标值，返回最接近目标值的三个数的和





思路:

- 思路其实和Algorithm Day73中的差不多，只不过返回的是值罢了
- 同理，为了方便一次遍历就能对比，我们首先对参数数组进行排序
- 将数组进行一次遍历，遍历时使用的索引值作为第一个数字的索引
- 将第二个数字的索引值初始化为第一个数字的后一位，第三个数字的索引值初始化为数组的最后一位
- 接下来将寻找最合适的第二三个数字，将它们的索引作为左右边界，该问题就转换为了二分法！
- 首先如果目前三个数字的和就是目标值，那么直接返回，不是则进行下面的步骤
- 如果目前三个数字的和离目标值的距离(通过差值的绝对值)，比当前的最小距离还小(minDVal)，则更新最小距离，并更新结果值
- 接下来进行二分法的传统做法: 如果当前的和小于目标值，则更新左边界(即第二个数字的值)，否则就更新右边(第三个数字的值)
- 将数组遍历一次后便可返回结果

****













# Day95

## Tag: Queue, Form Drive



![Xnip2021-06-28_08-14-57](Algorithem/Xnip2021-06-28_08-14-57.jpg)



![Xnip2021-06-28_10-03-33](Algorithem/Xnip2021-06-28_10-03-33.jpg)



题意:

给你一组数字字符串作为输入，请将其在手机键盘上对应字母的所有组合找出，并返回为一个集合





思路:

- 创建一个队列，将第一个数字对应的字符全部添加到其中
- 将第一次添加后的队列元素依次弹出，与第二个数字对应的字符进行组合，将每次组合后的结果添加到队列中
- 重复上面的步骤，直到遍历完输入的数字字符串





实现:



letterCombinations:

- 创建一个队列(这里用ArrayList这个常用的集合)，如果输入的字符串长度为0，直接返回这个队列(为空)
- 创建一个字符串数组，从下标0开始，每个元素都表示数字对应的字符(获取时将数字 -1即可)
- 将输入字符串遍历一次，每次遍历都添加到方法"letterCombination"中
- 最后返回该队列



letterCombination:

- 参数接收之前创建的队列，以及该次遍历中输入的数字对应的字符
- 如果是第一次调用，则队列为空，直接将第一次输入数字对应的字符全部添加到队列中
- 如果不是第一次，将队列中现存元素从开头弹出，并与本次遍历中输入的数字对应的字符进行组合，并将组合后的元素添加到队列尾即可

****













# Day96

## Tag: String, Math



![Xnip2021-06-29_09-34-13](Algorithem/Xnip2021-06-29_09-34-13.jpg)



![Xnip2021-06-29_09-41-06](Algorithem/Xnip2021-06-29_09-41-06.jpg)



题意:

给你一串数字，请你返回其在Excel表格中对应的行列号，对应关系应如下:

1 —> A

...

27—> AA

...





思路:

- 虽然场景是Excel表格，但其实是26进制转换问题
- 我们将输入的数字作为10进制，将其转换为26进制下对应的字母即可
- 想象我们是如何将10进制处理成2进制的？
- 每次除以进制2，将余数作为结果每一位上的数字
- 最后再反转一下即可(仅针对整数部分)







实现:

- 创建一个StringBuilder对象(最后可以利用其reverse()方法快速反转)，用于收集每一位处理后的结果
- 创建一个循环，将输入数字>0作为循环条件
- 在循环中实现取余数，添加到结果字符串，更新输入数字
- 最后将结果字符串反转后返回即可

****











# Day97

## Tag: Two Pointer, Array



![Xnip2021-06-30_12-37-25](Algorithem/Xnip2021-06-30_12-37-25.jpg)



![Xnip2021-06-30_12-53-49](Algorithem/Xnip2021-06-30_12-53-49.jpg)

题意:

给你一个数组和一个目标值，请你找出数组中所有4个数之和等于目标值的数组元素组合，结果不能重复











思路:

- 本题其实和之前做的许多题目都有关联，甚至做法都差不多，见:Algorithm Day15, 72, 94，想要了解这类题目可以从leetcode的第一题开始
- 还记得Day94最接近的三数之和还有Day72的三数之和吗？这道四数之和的做法和它们都差不多



- 回顾一下三数之和的做法:
- 首先对数组进行排序，然后固定一个数为索引，通过它将数组遍历一次
- 在遍历中，我们设立一个循环，通过双指针的方法寻找剩下的两个数，当前的和大于或者小于目标值，我们都更新对应的边界(即剩下两个数字的索引)，循环条件则为常规的左边界小于右边界



- 那么四数之和呢？
- 我们先固定一个数字，剩下的不就是三数之和的问题了吗?





实现:

- 创建一个结果集合，对测试数组进行判断，如果其长度小于4，那么就不可能有答案，直接返回结果集合即可
- 对数组进行排序，方便后续查找
- 对数组进行一次遍历，遍历的数字作为第一个数字的索引，此时我们已经固定了一个数字



以下为三数之和的步骤:

- 对数组进行一次遍历，起始的索引数为之前第一个数字索引的后一位，将其作为第二个数字的索引值
- 在遍历中初始化左边界和右边界，其分别为第二个数字索引的后一位和数组的最后位置
- 创建一个循环，条件为lefr<right
- 在循环中，如果四个数的和就是目标值，则将这四个数字组合为一个集合后添加到结果集合中，并更新索引
- 如果不相等，则更新对应的边界索引值即可
- 最后返回结果集合

****















# Day98

## SQL 43

****

















# Day99

## Tag: BFS, Array



![Xnip2021-07-02_20-56-10](Algorithem/Xnip2021-07-02_20-56-10.jpg)



![Xnip2021-07-02_21-16-30](Algorithem/Xnip2021-07-02_21-16-30.jpg)



题意:

给你一个二维数组，每个元素都为一个长度为2的数组，其中第一个数字代表该玩家的ID编号，另一个数字代表他所能传递的一下个玩家的编号

现在给你游戏的总人数n，要求你从编号为0的玩家开始，找出在k次传递后能传到最后一个玩家手里(编号n-1)的所有传递方式的总数









思路:

- 这道题目很明显可以使用广度/宽度优先搜索来做，类似Algorithm Day91
- 初始化一个队列存储玩家的ID，先将开始玩家的ID添加到其中(为0)
- 我们将以下的操作施行k次即可
- 弹出队列中现存所以玩家的ID，将其能传递给下一个的所有玩家的ID添加到队列中(如果其对应的下一个玩家ID为空，直接跳过添加的步骤)
- 施行k次后，判断队列中ID为最后一名玩家的数量，即沿着每条路都走k次，看看哪条路走到了对应的点







实现:

- 和Algorithm Day91不同的是，提供的数据中没有将每个玩家对应的下一个玩家ID整合起来，所以需要我们先手动整理一下
- 创建一个映射map，键值分别为玩家ID，和其所有的可传递玩家ID，为了能够将分布的ID对应到的同一个ID上，我们使用getOrDefault()方法重复获取每个ID对应的既存的可传递玩家ID，然后将其对应的既存可传递ID集合更新
- 创建一个队列，先将ID为0的玩家添加到其中，然后创建一个运行k次循环以模拟k次传递
- 在该循环中，再创建一个运行次数为现存队列元素数量的循环，在其中每次都弹出第一个元素，并将其对应的所有可传递ID添加到队列尾
- 最后，计算出队列中ID为最后一个ID的队列元素(n - 1)的数量即为答案

****











# Day100

## Tag: Array, Form Drive



![Xnip2021-07-03_22-33-04](Algorithem/Xnip2021-07-03_22-33-04.jpg)



![Xnip2021-07-04_11-41-58](Algorithem/Xnip2021-07-04_11-41-58.jpg)



题意:

给你一个字符串，请你将其中的字符按照的出现频率从高到低排序后，再返回该结果字符串









思路:

- 字符的范围为0~128，自然想到可以使用表驱动法来记录每个字符的出现次数
- 这里有一个问题，如果使用表驱动法，在完成记录后，我们需要将字符按照出现次数进行重组
- 这里我们要么每次都找出记录表中的最大值后进行追加，并将其删除；要么将该记录表按照出现次数进行排序，并记住排序后每个元素对应的ASCII码值
- 两种方法都有些复杂，我们需要一张按照出现次数排序后，仍然还保留每个字符的ASCII码值的数组
- 这里我们可以使用二维数组，刚开始时，行数则为对应的ASCII码值，每行都有一个长度为2的数组，该数组一个元素记录字符出现的次数，一个记录该字符对应的ASCII码值
- 这样一来，即使我们对其进行排序，行数改动后，每一行中都有一个元素保留有该行对应的ASCII码值









实现:

- 如上所述，创建一个二维数组record，共128行，每行2列
- 先将每列中数组的第一个元素初始化为对应的ASCII码值，再对参数字符串进行逐个字符的遍历，并将每个字符的出现次数记录到每列数组的第二个元素中
- 对该二维数组进行排序(这里用到了自定义的排序规则和lambda表达式)，按照排序后的数组顺序，添加对应的数量的字符，最后返回结果字符串

****











# Day101

## Tag: Math, Array



![Xnip2021-07-04_14-18-48](Algorithem/Xnip2021-07-04_14-18-48.jpg)



![Xnip2021-07-04_14-25-45](Algorithem/Xnip2021-07-04_14-25-45.jpg)



题意:

给你一个数组，其中的数字本来是从1到n没有重复的，但其中有一个数字因为一些错误发生了变化，使得该数组产生了重复的数字，请你找出重复的数字和该位置原本的数字并将两者以数组的形式返回





思路:

- 仔细观察后可以发现数学规律: 不管该参数数组是否有序，其未出错之前的和一定为从1到n(数组元素的个数)的和，我们将其作为"total"
- 对去掉重复元素后的数组求和为"nonRepeatSum"
- 再对当前的数组求和为"sum"
- 则重复的元素为sum - nonRepeatSum, 该位置原本正确的元素为total - nonRepeatSum









实现:

- 首先获取正常情况下从1到n的和(借用等差数列求和公式)
- 创建一个和参数数组大小一致的数组，用于排除重复的元素
- 将参数数组遍历一遍，计算其当前的总和sum和去掉重复数字后的和nonRepeatSum
- 最后返回sum - nonRepeatSum和total - nonRepeatSum即可


















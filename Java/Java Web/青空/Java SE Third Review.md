# 一、二进制表示法



## 1) 原码

- 最高位为符号位，最高位为0表示正数，为1表示负数

![Xnip2022-02-27_18-32-36](Java SE.assets/Xnip2022-02-27_18-32-36.jpg)



- -1用原码表示: 1001
- 1用原码表示: 0001



- 原码表示虽然简单，但在计算的时候会出现问题:

1 + (-1) = 0001 + 1001 = 1010 ≠ 0

<hr>







## 2) 反码

- 为了解决原码出现的问题，出现了反码:
    - 正数不变
    - 负数除了符号位，其余位取反表示



使用反码后计算1 + (-1 ):

1 + (-1) = 0001 + 1110 = 1111

再对结果取反: 1000 = -0



- 但问题是，如果1000 = -0，那么0000 = +0
- 在现实中，0应该没有符号才对，所以反码也不行

<hr>



​	







## 3) 补码

- 为了解决补码出现的问题，这里引入了补码:
    - 正数同样保持原码不变
    - 负数则先去反码，在反码的基础上 + 1后即可得到补码



使用补码计算1 + (-1):

- 1 + (-1) - > 0001 + 1110(反码) -> 0001 + 1111(补码) -> (1)0000(溢出位舍弃) = 0



因此，在Java中，负数都用补码来表示

<hr>












# 二、数据类型



## 1) 整数/字符/字符串

- byte: -128 ~ 127(1byte)
- short: -256 ~ 255(2byte)
- int: -2^31 ~ 2^31 - 1(4byte)，数字默认为int类型
- long: -2 ^ 31 ~ 2 ^ 31 - 1(8byte)，注意long类型数字末尾需加上"L"
- char: char(2yte)无符号，且对应的是Unicode编码表，这也是Java能使用中文作为变量名的原因，0 ~ 65535
    - char类型也可以使用'\uxxx'的形式来表示，最大为: \uFFFF

Eg:

![Xnip2022-02-27_20-37-01](Java SE.assets/Xnip2022-02-27_20-37-01.jpg)



- 如果数字大到long也放不下的话，可以使用BigInteger类:

![Xnip2022-02-27_20-39-56](Java SE.assets/Xnip2022-02-27_20-39-56.jpg)






# 十六、optimizer trace



## 16.1 简介

- 在MySQL5.6以及之前的版本中，查询优化器就是一个"黑盒"，我们只能通过EXPLAIN的方式查看最终的执行计划，而无法得知其为何做出这样的决定
- 而在之后的版本中，MySQL提供了名为optimizer trace的功能，该功能可以让用户方便的查看优化器生成执行计划的全过程



该功能的开启和关闭由系统变量optimizer_trace来决定

Eg:

![Xnip2021-11-17_15-09-43](MySQL Note.assets/Xnip2021-11-17_15-09-43.jpg)



**注意:**one_line值用来控制输出的格式，如果值为on，则输出都将在一行中展示，并不适合阅读，所以保持为off即可







原理:

- 打开optimizer trace功能后，**需要先执行一次想要查看优化过程的SQL语句，或者使用EXPLAIN查看一个执行计划**
- 之后只需要查看information_schema库下的OPTIMIZER_TRACE表即可



该表中有4列:

- QUERY: 表示输入的查询语句(我们自己写的SQL)
- TRACE: 表示优化过程的JSON文本
- MISSING_BYTES_BEYOND_MAX_MEN_SIZE: 如果生成过程中输出的内容超出了某个限制，则多余的文本不会显示。该字段表明剩余未显示内容的文本字节数
- INSUFFICIENT_PRIVILEGES: 表示是否有查看执行计划的权限，默认为0(有权限)，某些情况下为1(暂不关心)















## 16.2 通过optimizer trace分析查询优化器的具体工作过程

Eg:

![Xnip2021-11-17_15-24-45](MySQL Note.assets/Xnip2021-11-17_15-24-45.jpg)



优化过程的三个阶段:

- prepare阶段
- optimize阶段
- execute阶段



基于成本的优化主要集中在optimize阶段

- **对于单表查询来说**，主要关注的是**optimize阶段的rows_estimation过程**
- **对于多表连接查询来说**，主要关注的是**considered_execution_plans过程**

****





































# 十七、InnoDB的Buffer Pool



## 17.1 缓存的作用

- 数据始终会存放在磁盘内，所以而访问页中的记录时，会将整个页的数据加载到内存中
- 之后就可以进行读写访问了，**在读写访问之后并不着急释放页对应的内存空间，而是缓存起来**，之后**再次访问时就能省下读取表的I/O开销了**



## 17.2 InnoDB的Buffer Pool



### 17.2.1 Buffer Pool的定义

- 为了缓存从磁盘中读取的页，InnoDB会在MySQL服务器启动时就申请一片连续的内存，名为"Buffer Pool"
- 该缓存大小默认为128MB，可以通过在配置文件中指定innodb_buffer_pool_size这个启动项来指定其值

Configuration:

```mysql
[server]
innodb_buffer_pool_size = byte_nunmber
```

- 其单位为字节，其值不能太小，最小为5MB(小于5MB时MySQL会强制更正)





### 17.2.2 Buffer Pool内部组成

- Buffer Pool被划分成了若干页面，**该页面大小和InnoDB表空间使用的页面大小一致，都为16KB**
- 这里我们将**这些页面称为缓冲页**
- 为了管理这些缓冲页，**InnoDB为每个缓冲页都创建了一些控制信息**



- 每个缓冲页中对应的控制信息占用的内存大小是一致的，**每个页对应的控制信息占用的每块内存被称为一个控制块，控制块与缓冲页一一对应**
- **控制块在Buffer Pool的前面，缓冲页在后面**

Image:

![Xnip2021-11-18_16-51-40](MySQL Note.assets/Xnip2021-11-18_16-51-40.jpg)

- 我们设置的innodb_buffer_pool_size并不包含控制块占用的内存空间，所以在申请连续内存时，这片空间会比innodb_buffer_pool_size大5%
- 控制块大约占缓冲页大小的5%(DEBUG模式下，其余模式下会小一些)















### 17.2.3 free链表的管理

- 在启动服务器的时候需要完成Buffer Pool的初始化，也就是先向OS申请Buffer Pool的内存空间，划分为若干控制块和缓冲页
- 此时没有任何页面从磁盘缓存到Buffer Pool中



在从磁盘读取一个页到Buffer Pool时，该放到Buffer Pool中的哪个位置呢？或者说怎么区分Buffer Pool中哪些缓存页是空闲的？

- 我们可以把所有空闲缓冲页对应的控制块作为节点，放入一个链表内，该链表称为free链表
- 刚刚初始化后的Buffer Pool中 ，所有缓冲页都是空闲的

free链表的效果图:

![Xnip2021-11-19_14-07-12](MySQL Note.assets/Xnip2021-11-19_14-07-12.jpg)



- 如图，为了管理这个free链表，定义了一个基节点，其中包含了链表的头节点/尾节点地址。以及链表中节点的数量等等
- 基节点占用的内存空间并不包含在Buffer Pool中申请的大片连续的内存空间中，其是一块单独的内存空间



- 有了基节点之后，每当需要从磁盘中加载一个页到Buffer Pool中时，就**从free链表中获取一个空闲的页**，并**将该缓冲页对应的控制块的信息填好**，并**把该控制块从free链表中移除即可**




















### 17.2.4 缓冲页的哈希处理

- 之前说过缓冲页的作用: 访问某个页的数据时，将该页从磁盘加载到Buffer Pool中，如果已经在Buffer Pool中了，则直接使用即可



问题是，我们怎么知道所需的页在不在Buffer Pool中呢？难道要遍历Buffer Pool中的所有缓冲页吗？

- 之前我们定位一个页面就是通过表空间号与页号来获取页的
- 对应的，表空间号 + 页号就是一个key，缓冲控制块就是对应的value，建立一个哈希表即可





















### 17.2.5 flush链表的管理

- 如果我们修改了Buffer Pool中某个缓冲页的数据，其与**磁盘上的页就不一致了**(还未同步到磁盘内)，**这样的缓冲页称为脏页**(dirty page)
- 我们可以立即将修改刷新到磁盘上的对应页，但磁盘很慢，所以**频繁向磁盘写数据会影响程序的性能**
- 所以我们**并不能立即将修改同步到磁盘上**，而是**在未来的时间点进行刷新**(暂不介绍该时间点)



不能立即将修改刷新到磁盘上，那么怎么判断哪些页是脏页呢？

- 我们不得不再创建一个存储脏页的链表，其存储所有被修改过的缓冲页对应的控制块(脏页的控制块)
- 这个**链表节点对应的缓冲页都是需要刷新到磁盘上的，所以称为flush链表**，**构造和free链表差不多**

结构图:

![Xnip2021-11-19_14-35-04](MySQL Note.assets/Xnip2021-11-19_14-35-04.jpg)

总结: 缓冲页是空闲的，那就不可能是脏页，如果其是脏页，则肯定不是空闲的

























## 17.3 LRU链表的管理



### 1) 缓冲区不够的窘境

Buffer Pool对应的内存大小是有限的，如果需要缓冲的页占用的内存大小超过了Buffer Pool规定的大小，则需要将旧的缓冲页从中移除，再将新的页面放进去



问题是具体移除哪些页呢？

- 我们设立Buffer Pool的初衷是想减少磁盘I/O(减少从磁盘加载页的次数)
- 假设访问次数为n，则被访问的页在Buffer Pool中的次数 / n即为命中率，我们希望命中率越高越好
- 以聊天列表为例，经常使用的就在前面，不经常使用的就在后面，所以一旦超出了容量，则只会保留很频繁使用的列表







### 2) 简单的LRU链表

- 管理Buffer Pool其实也用的是这个道理。不过我们怎么知道哪些缓冲页最近使用频繁，哪些最近很少使用呢？
- 我们可以再创建一个链表，由于该链表是为了按照最少使用原则去淘汰缓冲页的，所以该链表可以被称为LRU链表(Least Recently Used)，当访问页面时按照如下方式处理LRU链表
    - 如果页不在Buffer Pool中，将该页从磁盘加载到Buffer Pool中的缓冲页时，就把该缓冲页对应的控制块作为节点塞到LRU链表的头部
    - 如果该页存在于Buffer Pool中，则直接把该页对应的控制块移动到LRU链表的头部
- 所以当使用到缓冲页时，则将该页调整到LRU的头部，此时尾部就是最近很少使用的缓冲页了，当Buffer Pool中的空闲缓冲页使用完时，淘汰掉链表尾部的链表即可









### 3) 划分区域的LRU链表

上述简单的链表其实有两个问题:



- 情况1: InnoDB提供一个服务——预读，所谓预读就是InnoDB认为执行当前请求时，可能会在后面读取某些页面，于是会预先将这些页面加载到Buffer Pool中。预读细分为两种:
    1. 线性预读: 如果读取一个区中的页面**超过了系统变量"innodb_read_aheaed_threshold"**，则会**触发一次异步读取下一个区中全部的页面到Buffer Pool中的请求**，由于是异步的，所以不会影响当前工作线程的正常执行，innodb_read_ahead_threshold系统变量的值默认为56，可以在启动时调整该变量，或者在运行时使用SET GLOBAL命令修改
    2. 随机预读: 如果某个区的13个连续的页面都被加载到了Buffer Pool中，无论这些页面是不是顺序读取的，都会触发一次异步读取本区所有页面到Buffer Pool中的请求，MySQL提供了innodb_random_ahead系统变量，默认值为OFF，说明该功能默认关闭，想开启同样需要使用SET GLOBAL设置为ON即可



预读本来是好事，如果预读到Buffer Pool中的页被成功地使用到了，那么可以提高效率，但如果用不到呢？

如果预读的页很多，但都用不到，则这些预读的页就会被很快地淘汰掉，大大降低Buffer Pool的命中率





- 情况2: 当需要全表扫描时，需要访问的页面特别多，此时Buffer Pool中的缓冲页可能会全部换一次，这回影响其他查询，从而降低Buffer Pool的命中率







总结，以下两种情况会降低Buffer Pool的命中率：

- 加载到Buffer Pool中的页不一定被用到(预读)
- 非常多使用频率较低的页被同时加载到Buffer Pool中




















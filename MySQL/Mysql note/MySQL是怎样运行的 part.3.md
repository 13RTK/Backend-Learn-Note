# 十、单表访问方法

- MySQL Server对一条SQL语句进行语法解析后(语法无误)，**会将其交给优化器进行优化**
- 优化的结果便是**执行计划**: 指定使用的索引、连接的顺序等等
- 最后按照执行计划中的步骤调用存储引擎接口来真正的查询，最后返回结果集



Eg Table:

![Xnip2021-10-21_10-29-23](MySQL Note.assets/Xnip2021-10-21_10-29-23.jpg)



![Xnip2021-10-21_10-29-32](MySQL Note.assets/Xnip2021-10-21_10-29-32.jpg)





## 10.1 访问方法

- MySQL官方将MySQL**执行查询语句的方式**，称为访问方法
- 同一条查询语句**可以使用多种访问方法**来执行







## 10.2 const

- **通过主键/唯一二级索引列**与**常数进行等值比较**，来**定位一条记录**的访问方法定义为const
- 如果**索引有多个列(联合索引)**，则只有索引中**每个列都与常数进行等值比较时**，const访问方法才有效

Eg SQL:

```mysql
SELECT * FROM single_table WHERE id = 1438;
SELECT * FROM single_table WHERE key2 = 3841;
```





**注意：**对于唯一二级索引列，查询列为NULL时，比较特殊

```mysql
SELECT * FROM single_table WHERE key2 IS NULL;
```

- 因为唯一二级索引中为**null值的记录数量没有限制**，所以**查询结果可能有多条记录**，**因此也不能用const**













## 10.3 ref

- 搜索条件为**二级索引列与常数进行等值比较**，**形成的扫描区间为单点扫描区间**，**采用二级索引执行查询**的访问方法为ref
- 需要回表

Eg SQL:

```mysql
SELECT * FROM single_table WHERE key1 = 'abc';
```

- 每获取一条二级索引记录，**就会立马对其执行回表操作**





过程:

![Xnip2021-10-21_10-41-50](MySQL Note.assets/Xnip2021-10-21_10-41-50.jpg)

- 由于通过普通二级索引列进行等值比较后，可能会匹配到多条记录，所以该ref访问方法比const要查一点



**注意：**

1. 二级索引允许存储null，其不限制null的数量，所以**在对二级索引列执行IS NULL条件查询时，只能使用ref**
2. 对于联合二级索引来说，只要前面的连续索引列是与常数进行等值比较，就能使用ref方法

Eg SQL:

```mysql
SELECT * FROM single_table WHERE key_part1 = 'god like' AND key_part2 = 'legendary'
```

- 联合索引idx_key_part，key_part1和key_part2是按照顺序的，所以能够使用ref





- 如果左边的连续列不全是等值的话，就不能用ref方法:

```mysql
SELECT * FROM single_table WHERE key_part1 = 'god like' AND key_part2 > 'legendary'
```

















## 10.4 ref_or_null

- 在ref的基础上，还需要将列中值为null的记录也找出，该种执行方法即为ref_or_null
- 只是比ref访问方法多扫描了一些值为null的二级索引记录
- 值为null的记录会被放在索引的最左边

Eg SQL:

```mysql
SELECT * FROM single_table WHERE key1 = 'abc' OR Key1 IS NULL;
```





执行过程:

![Xnip2021-10-21_10-57-08](MySQL Note.assets/Xnip2021-10-21_10-57-08.jpg)















## 10.5 range

- 使用索引进行查询时，**对应的扫描区间为若干单点扫描区间或者范围扫描区间的访问方法为range**

Eg SQL:

```mysql
SELECT * FROM single_table WHERE key2 IN (1438, 6328) OR key2 >= 38 AND key2 <= 79;
```



**注意：**

- 仅包含一个单点扫描区间或者区间为(-∞, +∞)的访问方法不能称为range













## 10.6 index

- **扫描全部二级索引记录的访问方法为index**

Eg SQL

```mysql
SELECT key_part1, key_part2, key_part3 FROM single_table WHERE key_part2 = 'abc';
```

- 左边的索引列并不连续，无法形成合适的范围区间来减少需要扫描的记录数



其符合两个条件:

1. **索引idx_key_part包含所有查询列表中的列**(索引列包含查询列)
2. 搜索条件key_part2包含在索引中



- 我们可以**直接遍历idx_key_part索引中的所有二级索引记录**，并通过WHERE子句条件进行判断
- 该方式**不需要进行回表操作**

















## 10.7 all

- 全表扫描对应的访问方法为all



















## 10.8 索引合并

- **使用多个索引完成一次查询**的**执行方法为index merge索引合并**



具体的索引合并方法有三种:

### 1) Intersection

Eg SQL:

```mysql
SELECT * FROM single_table WHERE key1 = 'a' AND key3 = 'b';
```



执行该查询的三种方案:

1. 使用idx_key1索引进行查询

对应的扫描区间为['a', 'a']，对于获取到的每条二级索引记录，都会根据其中的id值(主键列)进行回表操作，再判断key3 = 'b'

因为**扫描区间为一个单点扫描区间**，**所以该区间中的二级索引记录都是按照主键值排序的**





2. 使用idx_key3进行查询

对应的扫描区间为['b', 'b']，对于获取到的每条二级索引记录，都会根据其中的id值(主键列)进行回表操作，再判断key1 = 'a'

因为**扫描区间为一个单点扫描区间**，**所以该区间中的二级索引记录都是按照主键值排序的**





3. 同时使用idx_key1和idx_key3进行查询

在idx_key1中扫描['a', 'a']内的二级索引记录，同时在idx_key3中扫描['b', 'b']内的二级索引记录，**找出两个操作结果中id值相同的记录**

最后再根据共有的id进行回表操作(能省下很多回表操作带来的开销)



**这里的方法3就是intersection索引合并**:

- 对从**不同索引中扫描到的记录id取交集**，**只为这些id执行回表操作**
- **使用二级索引时**，**从二级索引中获取的记录必须要以主键值排列**







为什么要求从二级索引获取到的记录要按照主键值排序好？

- 从两个有序集合中取交集比两个无序集合要容易
- 如果获取的id时有序的，则进行**回表时则不会进行单纯的随机I/O**，能有效的提高效率







方法3步骤:

![Xnip2021-10-21_14-32-25](MySQL Note.assets/Xnip2021-10-21_14-32-25.jpg)







如果**用二级索引从扫描区间中获取的二级索引记录不是按照主键值排序的**，则**不能使用Intersections索引合并方式执行**

```mysql
SELECT * FROM single_table WHERE key1 > 'a' AND key3 = 'b';
```

- 使用索引idx_key1在区间['a', +∞]中获取的记录不是按照主键值排序的，所以不能使用Intersection索引合并的方法执行









如果WHERE子句中含有聚簇索引则:

Eg SQL:

```mysql
SELECT * FROM single_table WHERE key1 = 'a' AND id > 9000;
```

ID会和key1 = 'a'形成扫描区间: (('a', 9000), ('a', +∞))，此时直接扫描二级索引idx_key1即可，不需要扫描聚簇索引



















### 2) Union

- 通过二级索引查询出的二级索引记录的id值进行去重，根据去重后的id进行回表操作，重复的id只需要回表一次



Eg SQL:

```mysql
SELECT * FROM single_table WHERE key1 = 'a' OR key3 = 'b'
```

- 同时使用idx_key1和idx_key3索引执行查询，从两个获取索引记录的id中进行去重，根据去重的id执行回表操作
- 重复的id只回表一次



**注意：**从索引中获取的**记录必须都是按照主键值进行排序的**

理由同Intersection







Eg SQL:

```mysql
SELECT * FROM single_table WHERE (key_part1 = 'a' AND key_part2 = 'b' AND key_part3 = 'c') OR (key1 = 'a' AND key3 = 'b');
```

- 先通过idx_key1和idx_key3执行Intersection索引合并(key1 = 'a' AND key3 = 'b')
- 在通过idx_key_part执行索引合并即可

















### 3) Sort-Union

- 使用Union的条件很苛刻: **通过索引获取的记录必须是按照主键值排序的**
- Sort-Union比起Union**只多了一步对二级索引记录的主键值进行排序的过程**

为了让Union更加易用，出现了Sort-Union



Eg SQL:

```mysql
SELECT * FROM single_table WHERE key1 < 'a' OR key3 > 'z'
```

- 先根据key1 < 'a'从索引idx_key1中获取二级索引记录，**并将获取到记录按主键值进行排序**
- 在根据key3 > 'z'从索引idx_key3中获取二级索引记录，**并将获取到记录按主键值进行排序**
- 此时对应记录都是按照主键值排序的了，**剩下的部分和Union一样**



拓展:

- MySQL中并没有Sort-intersection，但MariaDB中实现了Sort-Intersection
- Intersection是为了只回表查询多个条件都符合的主键值(回表开销过大时)，Union是为了去除重复的主键值

****























# 十一、连接原理

- 从本质上说: 连接就是把各个表中的记录都取出来进行依次匹配，并把匹配后的组合发送给client

Eg Table:

```mysql
CREATE TABLE t1 (m1 int, n1 char(1));

CREATE TABLE t2 (m2 int, n2 char(1));

INSERT INTO t1 VALUES(1, 'a'), (2, 'b'), (3, 'c');

INSERT INTO t2 VALUES(2, 'b'), (3, 'c'), (4, 'd');
```









## 11.1 连接简介





### 11.1.1 连接过程

- 如果在连接时不给出任何限制条件，则产生的笛卡尔积会非常巨大，所以连接时过滤记录是必要的
- 查询中过滤条件分为两种:



1. 单表条件:

其实就是之前说过的搜索条件

2. 涉及多表的过滤条件







连接查询大致过程

Eg SQL:

```mysql
SELECT * FROM t1, t2 WHERE t1.m1 > 1 AND t1.m1 = t2.m2 AND t2.n2 < 'd';
```





1. 确定第一个需要查询的表(**驱动表**)

单表查询其实只需要选择代价最小的那种访问方法执行即可(const, ref, ref_or_null等)

假如以t1为驱动表: 需要查找满足t1.m1 > 1的记录，因为数据量很少，所以无法创建二级索引，此时使用all执行方法(全表扫描)

2. 步骤1**每获取一条记录，都从t2中查找匹配的记录**



过程图:

![Xnip2021-10-21_16-11-43](MySQL Note.assets/Xnip2021-10-21_16-11-43.jpg)



- 总结:

两表连接查询中，**驱动表只需要访问一次**，而**被驱动表可能会需要访问多次**





- 强调:

这里并不是先将所有从驱动表搜索出来的记录放到一个地方，再去被驱动表中查询的，**而是每获得一条记录后马上到被驱动表中匹配**















### 11.1.2 内连接和外连接



内外连接的区分: 

有时**即使在被驱动表中没有找到匹配的记录，仍然需要把驱动表的结果放入结果集**，为了解决该问题才有了内外连接

- 内连接: 如果驱动表中的记录在被驱动表中找到不匹配的记录，则该记录不会添加到结果集
- 外连接: 如果驱动表中的记录在被驱动表中找到不匹配的记录，该记录仍然会添加到结果集



两种外连接:

- 左外连接: 选择左侧的表作为驱动表
- 右外连接: 选择右侧的表作为驱动表



WHERE和ON:

- 无论是内外连接，**被WHERE过滤掉的记录都不会被添加到结果集**
- 对于外连接驱动表中的记录: 如果**无法在被驱动表中找到匹配的记录**，该驱动表记录**依然会加入到最后的结果集**



**注意：**ON子句是专为外连接提出的，如果在内连接中使用，MySQL会把它像WHERE子句一样对待，**内连接中WHERE和ON是等价的**





#### 1) 外连接语法

```mysql
SELECT column FROM table1 LEFT/RIGHT (OUTER) JOIN table2 ON (join condition) WHERE (condition)
```

- OUTER可省略





#### 2) 内连接语法

```mysql
SELECT columns FROM table1 (INNNER/CROSS) JOIN table2 (ON condition) (WHERE condition)
```

- Inner/cross和省略的写法都是等价的
- 由于内连接中ON子句和WHERE是等价的，所以内连接可以没有ON子句





















## 11.2 连接原理



### 11.2.1 嵌套循环连接(Nested-Loop Join)

- 定义：驱动表只访问一次，但被驱动表却可能访问多次，而且**访问次数取决于驱动表查询后结果集中记录的数量**
- 类似嵌套了很多for循环



简述过程:

![Xnip2021-10-21_16-37-56](MySQL Note.assets/Xnip2021-10-21_16-37-56.jpg)



**注意：**对于循环嵌套算法来说，**每当从驱动表中获取了一条记录，则会马上通过该记录在被驱动表中查询一次并发送给client**

















### 11.2.2 使用索引加快连接速度

Eg SQL:

```mysql
SELECT * FROM t1, t2 WHERE t1.m1 > 1 AND t1.m1 = t2.m2 AND t2.n2 < 'd';
```

- 该查询使用的是嵌套循环连接算法，查询的执行过程为:

![Xnip2021-10-21_16-47-20](MySQL Note.assets/Xnip2021-10-21_16-47-20.jpg)

- 条件t1.m1 = t2.m2在针对t2表进行查询时，t1表的条件就已经确定了，所以我们只需要优化针对t2表的查询即可
- 根据t2条件可以进行如下尝试:



1. 在m2列上建立索引

因为针对m2列的条件是等值比较，可以使用ref访问方法执行查询，回表后再判断t2.n2 < 'd'

- 如果m2列是t2表的主键或者不为null的唯一二级索引，则单表查询时为const
- **在连接查询中**，**对被驱动表的主键或者不为null的唯一二级索引进行等值查找**的使用方法为**eq_ref**



2. 在n2列上建立索引

- 此时可能用到range访问方法，其需要回表后再判断t2.m2列的条件









**补充：**

- 如果两列都有索引，则挑一个代价低的进行查询
- 如果查询列表和过滤条件中的列存在于二级索引中，那么此时可使用index访问方法(不需要回表)，**所以为了能使用更多的访问方法，最好不要使用*作为查询列表**















### 11.2.3 基于块的嵌套循环连接

- 由于被驱动表可能被扫描多次，内存中可能会无法放下一张完整的表，此时需要频繁地释放内存
- 当被驱动表中数据很多，且无法使用索引进行访问时，相当于要从磁盘上多次读取该表，I/O代价较大
- 我们需要减少被驱动表的访问次数



- 为了减少I/O损耗，可以使用Join Buffer(连接缓冲区)**先装下若干驱动表结果集中的记录**
- 之后再**将被驱动表中的每条记录一次性地与Join Buffer中的多条驱动表记录进行匹配**(匹配过程在内存中进行，可以显著减少被驱动表的I/O损耗)
- Join Buffer: **在查询执行前申请的一块固定大小的内存**

使用过程:

![Xnip2021-10-21_21-53-27](MySQL Note.assets/Xnip2021-10-21_21-53-27.jpg)

- **最好的情况是Join Buffer足够大，能够容纳驱动表结果集中的所有记录**，这样就**只需要访问一次**被驱动表了
- 这种加入了块的嵌套循环连接算法称为**基于块的嵌套循环连接算法**(Block Nested-Loop Join)



设置:

- Join Buffer的大小可以通过启动项或者系统变量join_buffer_size进行配置:

![Xnip2021-10-21_21-58-26](MySQL Note.assets/Xnip2021-10-21_21-58-26.jpg)

- 其默认大小为256KB
- 在优化被驱动表的查询时，最好为被驱动表创建索引，**实在不能创建索引则可以尝试将join_buffer_size调大**
- join buffer并不会存放驱动表记录中的所有列，**只会存放查询列表和过滤条件中的列**，**所以最好不要使用*，这样可以在join buffer中存放更多的记录**

****



















# 十二、基于成本的优化



## 12.1 成本的定义

- I/O成本: 查询记录时，需要将数据/索引从磁盘加载到内存中，之后再进行操作，**从磁盘到内存的加载过程损耗的时间称为I/O成本**
- CPU成本: 读取/检测记录是否满足对应的搜索条件，对结果集进行排序**这些操作损耗的时间称为CPU成本**



对InnoDB存储引擎来说，页是磁盘与内存之间交互的基本单位，读取一个页面的默认成本为1.0，读取/检测一条记录是否符合搜索条件的成本默认为0.2，1.0和0.2这些数字被称为成本常数(这两个成本最常用)

**注意:** 即使不需要检测记录是否符合，读取记录时的成本也为0.2







## 12.2 单表查询的成本



### 12.2.1 准备工作

Eg Table:

```mysql
CREATE TABLE single_table(
	id INT NOT NULL AUTO_INCREMENT,
  key1 VARCHAR(100),
  key2 INT,
  key3 VARCHAR(100),
  key_part1 VARCHAR(100),
  key_part2 VARCHAR(100),
  key_part3 VARCHAR(100),
  common_field VARCHAR(100),
  PRIMARY KEY(id),
  KEY_idx_key1 (key1),
  UNIQUE KEY uk_key2 (key2),
  KEY idx_key3 (key3)
  KEY idx_key_part(key_part1, key_part2, key_part3)
)Engine=InnoDB CHARSET=utf8;
```





### 12.2.2 基于成本的优化步骤

- 在**执行一条查询之前**，MySQL的**优化器会找出所有可以用来执行该查询语句的方案**
- 对比后选择**成本最低的方案，该方案就是执行计划**，之后才会调用存储引擎提供的接口执行查询

大致过程:

1. 根据搜索条件**找出所有可能使用的索引**
2. **计算全表扫描的代价**
3. 计算**使用不同索引执行查询的代价**
4. 对比各种执行方案的代价，**找出成本最低的方案**



实例:

```mysql
SELECT * FROM single_table WHERE
	key1 IN ('a', 'b', 'c') AND
	key2 > 10 AND key2 < 1000 AND
	key3 > key2 AND
	key_part1 LIKE '%hello%' AND
	common_field = '123';
```





#### 1) 根据搜索条件，找出所有可能使用的索引

- MySQL设计者将一个查询中可能使用到的索引称为possible keys
- key1 IN (...): 可以使用索引idx_key1
- key2 > 10 AND ...: 可以使用索引idx_key2
- key3 > key2: 没有与常数比较，无法形成合适的扫描区间
- key_part1 LIKE '%hello%': 通过LIKE和通配符匹配，不能产生合适的扫描区间
- common_field = '123': 没有在该列上建立索引，所以不会用到索引







#### 2) 计算全表扫描的代价

- 对于InnoDB表: 全表扫描即将所有的聚簇索引记录依次与给定的搜索条件进行比较

- 符合搜索条件的加入到结果集中

- 需要将聚簇索引对应页加载到内存中，在检测是否符合搜索条件，查询成本 = I/O成本 + CPU成本

- 计算全表扫描的代价时需要两个信息:

  - 聚簇索引占用的页面数
  - 该表中的记录数

  

- 如何获取上述两个信息:

  - MySQL设计者在每个表中都维护了一系列的统计信息，可以直接查看:

Syntax:

```mysql
SHOW TABLE STATUS LIKES 'table_name'\G;		// \G可以将所有数据竖直输出
```

![Xnip2021-11-01_10-57-23](MySQL Note.assets/Xnip2021-11-01_10-57-23.jpg)

- 目前只关心两个选项:
  - Rows: 表示**表内记录的条数**(**对于InnoDB存储引擎表来说该值为一个估计值**，对于MyISAM存储引擎表来说该值是准确的)，
  - Data_length: **表示表占用的存储空间字节数**，对于MyISAM表其为数据文件的大小，**对于InnoDB表其为聚簇索引占用的存储空间大小**，可按照如下公式计算: 聚簇索引页面数 * 每个页面的大小:

65536 / 16 /1024 = 4，所以聚簇索引所占的页面数为4



计算过程:

- I/O成本: 4 * 1.0 + 1.1 = 5.1

4指的是聚簇索引页的数量，1.0指一个加载页面的成本常数，1.1为一个微调值，不用在意

- CPU成本: 1000 * 0.2 + 1.0 = 101

1000指记录的数量，0.2指访问一条记录的成本常数，1.0是一个微调值

- 总成本: 106.1

全表扫描的成本为106.1



**注意：**正常来说全表扫描中只需要扫描叶子结点，不需要扫描内节点，但**在计算成本时直接计算了整个聚簇占用的页面数**(没有区分)















#### 3) 计算不同索引执行查询的代价

- MySQL查询优化器总是**先分析唯一二级索引的成本**，再分析普通索引的成本



1) 使用uk_key2索引

执行查询该索引使用了二级索引 + 回表的方式，计算查询成本时需要考虑两方面的数据: **扫描区间数量和需要回表的记录数**

- 扫描区间数量:

无论扫描区间内的二级索引占用多少页面，查询优化器都**认为读取一个扫描区间的I/O成本与读取一个页面的成本一致**

- 需要回表的记录数:

查询优化器需要计算二级索引某个扫描区间包含多少记录:

1. 首先根据条件找到第一条记录(根据B+树定位记录是很快的，消耗可以忽略不计
2. 在获取最后一条满足条件的记录
3. 只要左右边界记录间隔不大，就可以精确统计出条件中的二级索引记录条数



**注意:** 在Index_Page中有一个Page Header部分，其中**一个名为PAGE_N_RECS的属性，该属性代表页面中的记录数**，所以如果条件中左右记录相差不远，则直接累加中间页面中的PAGE_N_RECS值即可

如果左右相隔比较远，则只从左第一条记录向右读取10个页面，计算页面中的平均记录，之后用平均值 * 页面数





那怎么获取页面数呢？

- 通过包含区间所有记录的父节点中目录项记录之间的记录数即可
- 如果在上一层中一个父节点页无法全部包含，则取再往上一级的父节点页即可

![Xnip2021-11-01_14-23-54](MySQL Note.assets/Xnip2021-11-01_14-23-54.jpg)

- 假如在区间(10, 1000)中有大概95条记录，则读取二级索引对应的CPU成本为: 95 * 0.2 + 0.01 = 19.01(0.01为微调值)
- 回表操作:
  - 评估回表操作的I/O成本时，每次回表操作都相当于访问一个页面，也就是说二级索引扫描区内有多少记录，就需要进行多少次回表操作，共95条记录，则需要回表95次，消耗的I/O成本为95 * 1.0 = 95

- 回表后的记录需要再使用搜索条件进行判断，共95条，则读取并检测的CPU成本为: 95 * 0.2 = 19
- 最后总成本为: 
  - I/O成本: 1.0 + 95 * 1.0 = 96.0
  - CPU成本: 95 * 0.2 + 0.01 + 95 * 0.2 = 38.01

共134.01



**注意：**MySQL中在最初比较使用二级索引的时候，**会先忽略掉回表后检测聚簇索引记录的成本**。**如果计算后使用该索引的成本最低，则再加上最后检测聚簇索引记录的成本后再次进行计算**















2. 使用idx_key1执行查询

- 对应的搜索条件: key1 IN('a', 'b', 'c')，相当于三个单点扫描区间



- 扫描区间的数量

三个扫描区间，付出的I/O成本为3 * 1.0 = 3.0



之后同上:

![Xnip2021-11-01_15-44-03](MySQL Note.assets/Xnip2021-11-01_15-44-03.jpg)

综上:

总成本为121.0 + 47.21 = 168.21









3. 索引合并

- 查询到的二级索引不是按照主键值排列的，所以不会使用Intersection索引合并













#### 4) 对比各种执行方案的代价，找出成分最低的方案

在本例子中各种可执行方案及对应成本:

- 全表扫描: 2037.7
- 使用uk_key2: 134.01
- 使用idx_key1: 168.21

注意:

![Xnip2021-11-01_16-30-58](MySQL Note.assets/Xnip2021-11-01_16-30-58.jpg)















### 12.2.3 基于索引统计数据的成本计算

- 使用索引执行查询时，需要算一下索引记录的条数
- 先获取索引对应B+树的左右最值记录，再计算两条记录间有多少记录
- MySQL设计者将这种**通过直接访问索引对应B+树来计算某个扫描区间内索引记录条数的方法**，称为**index dive**



- 如果**对应单点扫描区间过多**，则需要多次重复扫描索引，开销极大
- MySQL设计者设定了一个变量: "eq_range_index_dive_limit"，默认为200
- 其**限定了可以使用index dive的最大单点区间数**

![Xnip2021-11-01_16-45-10](MySQL Note.assets/Xnip2021-11-01_16-45-10.jpg)

- 如果单点区间数超过了这个限制，则需要使用索引统计数据(index statistics)



查看索引统计数据:

![Xnip2021-11-01_16-51-16](MySQL Note.assets/Xnip2021-11-01_16-51-16.jpg)



各个列属性和含义:

![Xnip2021-11-01_16-52-50](MySQL Note.assets/Xnip2021-11-01_16-52-50.jpg)

- Cardinality: 基数，代表某个列中不重复的值的个数，对于InnoDB存储引擎来说，该Cardinality是一个估计值




- 之前说过: 如果单点扫描区间数超过了变量eq_range_index_dive_limit限定的值，则会使用索引统计数据来计算各个区间对应的索引记录数，其指如下两个值:
  - show table status里显示出来的Rows值(表示表中记录的数量)
  - show index显示出来的Cardinality属性

- 我们可以**根据这两个值来计算出一个列中一个值平均重复了多少次**: Rows / Cardinality
- **得出的平均值即为单个扫描区间对应的大致记录数**
- 通过统计数据来计算比扫描索引要快，**但其缺点为不准确**





**注意：**在MySQL5.7.3及之前的版本中，eq_range_index_dive_limit的默认值为10，但之后都为200















## 12.3 连接查询的成本



### 12.3.1 准备工作

- 之后将single_table写作s1，将single_table写作s2





### 12.3.2 条件过滤

- MySQL连接查询使用的是嵌套循环连接算法，所以其两表连接的查询成本分为两个方面:
  - 单词查询驱动表的成本
  - 多次查询被驱动表的成本(取决于驱动表查询后结果集中的记录数)



- 我们将**通过驱动表查询出的记录数称作扇出(fanout)**，扇出值越小，对被驱动表的查询次数越少，对于总查询成本越低

计算扇出的例子:

![Xnip2021-11-02_09-01-17](MySQL Note.assets/Xnip2021-11-02_09-01-17.jpg)



![Xnip2021-11-02_09-01-36](MySQL Note.assets/Xnip2021-11-02_09-01-36.jpg)

- 总结起来就是:在一下两种情况下，计算驱动表扇出值时，需要靠猜测:
  - **使用全表扫描的方式执行单表扫描时**，需要猜测满足所有搜索条件的记录条数
  - **使用索引来执行单表查询时**，需要**猜测满足形成索引扫描区间的条件外，还满足其他搜索条件的条数**



- MySQL设计者将这个猜测过程称为Condition Filtering(条件过滤)，可能使用索引或者统计数据















### 12.3.3 两表连接的成本分析

- 连接查询的成本计算公式: 单次访问驱动表的成本 + 驱动表扇出值 * 单次访问被驱动表的成本
- 对于外连接查询来说，**只需要为驱动表和被驱动表选择成本最低的访问方法即可**
- 内连接则需要考虑不同表作为驱动表的情况，**需要考虑最佳的表连接顺序**



计算最优内连接查询方案例子:

Eg SQL:

```mysql
SELECT * FROM s1 INNER JOIN s2
	ON s1.key1 = s2.common_field
	WHERE s1.key2 > 10 AND s1.key2 < 1000 AND
	s2.key2 > 1000 AND s2.key2 < 2000;
```







#### 1) 使用s1作为驱动表

涉及s1这一单表的搜索条件:

- s1.key2 > 10 AND s1.key2 < 1000





从使用全表扫描和uk_key2索引这两个方案中选择成本最低的一个即可，之后涉及被驱动表s2的搜索条件为:

- s2.common_field = 常数(针对驱动表中每一条记录，都需要访问一次被驱动表s2，**此时s1对于的值固定，涉及两表的条件此时只涉及被驱动表**)
- s2.key2 > 1000 AND s2.key < 2000

common_field没有索引，此时访问s2表的方法只有使用全表扫描和uk_key2两种

最后使用s1作为驱动表的成本为(**暂不考虑使用Join Buffer**):

使用uk_key2访问s1的成本 + s1扇出值 * 使用访问uk_key2访问s2的成本

















#### 2) 使用s2作为驱动表

涉及s2这一单表的搜索条件:

- s2.key2 > 1000 AND s2.key2 < 2000



从使用全表扫描和uk_key2索引这两个方案中选择成本最低的一个即可，之后涉及被驱动表s2的搜索条件为:

s1.key1 = 常数

s1.key2 > 10 AND s1.key2 < 1000

- 这里可以通过idx_key1使用ref访问方法，也可以通过uk_key2使用range访问方法，也可以使用全表扫描，从中选择一个即可
- 其中range方法时区间是确定的，但使用idx_key1的成本不确定，其实使用统计数据计算出一个平均每个值的重复次数即可
- 假定这里选用了idx_key1，则总成本为:

使用uk_key2访问s2的成本 + s2的扇出值 * 使用idx_key1访问s1的成本







- 其中占大头的为驱动表扇出值 * 单次访问被驱动表的成本，所以我们需要重点优化一下两点:
  - 减少驱动表的扇出
  - 减少被驱动表的访问次数(最好在被驱动表的连接列上建立索引，这样就能使用ref了，如果可以最好将主键或者唯一二级索引作为连接列)

















### 12.3.4 多表连接的成本分析

- 连接n张表，则有n!种连接顺序
- MySQL查询优化器会计算每种连接顺序的成本，为了减少因计算不同连接顺序的成本而带来的损耗，有几种方法:



1. 提前结束某种连接顺序的成本估计

在计算各种顺序的连接成本之前，会**维护一个全局变量，其代表当前最小的连接查询成本**，一旦在**计算当前连接顺序的成本已经大于该值时，则不再继续分析了**(该方法一定不是最优)



2. 系统变量optimizer_search_depth

如果连接表的个数小于该值，则继续计算该连接顺序的成本，**如果大于，则只计算连接该变量数量以内的表的成本**。

该值越大，越能得到好执行计划，但耗时越长



3. 启发式规则不考虑某些连接顺序

MySQL设计者提出了一些启发性规则(基于以往的经验)，不满足该规则的连接顺序则不分析，提供了一个系统变量optimizer_prune_level来控制是否使用这些规则













## 12.4 调节成本常数

之前提到的两个成本常数:

- 读取一个页面的成本默认为1.0
- 读取及检测一条记录是否符合搜索条件的成本为0.2



其余的成本常数都存储在MySQL库对应的两张表中:

![Xnip2021-11-02_09-51-41](MySQL Note.assets/Xnip2021-11-02_09-51-41.jpg)

- 一条语句执行时分别在server和存储引擎层执行
- 在server层执行连接管理、查询缓存、语法解析、查询优化等操作，在存储引擎层执行具体的数据存取操作
- 语句在server层操作的成本与其操作表时使用的引擎无关











### 12.4.1 mysql.server_cost

该表记录了在server进行操作对于的成本常数:

![Xnip2021-11-02_09-55-31](MySQL Note.assets/Xnip2021-11-02_09-55-31.jpg)

- cost_name: 成本常数的名称
- cost_value: 成本常数对应的值。该值为null时则取默认值
- last_update: 最后更新记录的时间
- comment: 注释



其对应的成本常数:

![Xnip2021-11-02_09-58-04](MySQL Note.assets/Xnip2021-11-02_09-58-04.jpg)

拓展:




















# 二十、undo日志



## 20.1 事务回滚的需求

- Server, OS错误
- 手动rollback



回滚时需要记录的东西:

- 插入记录时，记下记录的主键值，回滚时将主键值对应的记录删除即可
- 删除记录时，记下插入数据的内容，回滚时将这些内容组成记录后插入回原表中即可
- 修改记录时，需要记录下更新列的旧值，回滚时将这些列设置为旧值即可



这些为了回滚而记录的东西称为undo日志









## 20.2 事务id



### 20.2.1 分配事务id的时机



事务可以是一个只读事务，也可以是一个读写事务(默认)



如果事务在执行时对表进行了改动(不含读取)，那么InnoDB会为它分配一个独一无二的事务id。

分配的方式:

- 对于只读事务来说:

之后**只有在它第一次对某个用户创建的临时表执行改动时**，才会分配一个独一无二的事务id



例如:

在使用EXPLAIN分析查询计划的时候，有时会在Extra列看到Using temporary的提示，说明在执行时会用到内部的临时表，在事务回滚时，并不需要将该临时表也回滚，所以也不会为该事务分配事务id





- 对于读写事务来说，只有在其第一次对表CRUD时才会为事务分配一个唯一事务id，否则不会为该事务分配事务id



现在只需要知道:

只有在事务对表进行改动时才会为其分配一个事务id(没有分配时，事务的默认id为0)

























### 20.2.2 事务id的生成

事务id本质为一个数字，分配策略如下:



- 服务器会在内存中维护一个全局变量，每当需要分配事务id时，就将该变量的值作为事务id分配给事务，之后该变量 + 1
- 当该变量的值为256的倍数时，将该值刷新到系统表空间中页号为5的页面中一个名为Max Trx ID的属性中，该属性占用8字节的存储空间
- 重启后，该值会加上256后赋值给之前的全局变量(变量的值可能大于该Max Trx ID的值)

这样就能保证事务id是一个递增的数字了



















### 20.2.3 trx_id隐藏列



之前在行格式中说过，聚簇索引记录除了用户记录外，还会添加名为trx_id、roll_pointer的隐藏列(如果没有主键和不为null的唯一键，还会添加一个row_id列)





其中的trx_id就是**对该聚簇索引记录进行修改的语句所在事务对应的事务id**



















## 20.3 undo日志格式



为了实现原子性，InnoDB在进行实际的CUD之前，会先将对应的undo日志记录下来

一个事务会对应多条undo日志，**这些undo日志从0开始编号，这个编号称为undo no**



这些undo日志被记录到类型为FIL_PAGE_UNDO_LOG的页面中，这些页面从系统表空间中分配，也可以从一个专门存放undo日志的表空间(undo tablespace)中分配





不同的操作都会产生怎样的undo日志呢？

Eg table:

![Xnip2021-12-03_14-52-51](MySQL Note.assets/Xnip2021-12-03_14-52-51.jpg)

- 记住table_id

















### 20.3.1 INSERT操作对应的undo日志



在插入记录时，最终的结果都是将该记录插入到数据页中，在写对应undo日志时，只需要将该记录的主键值记录好就行了



该undo日志的类型为TRX_UNDO_INSERT_REC，完整结构为:

![Xnip2021-12-03_15-01-14](MySQL Note.assets/Xnip2021-12-03_15-01-14.jpg)



- undo no在事务是从0开始递增的。只要事务没有提交，**每生成一条undo日志，该日志的undo no自增**
- 如果**记录的主键只含一列**，该上述类型的undo日志中，只需要将列占用存储空间大小和真实值记录下来即可

**如果包含多个列，则需要将每个列的存储空间和真实值都记录下来**，len表示列占用的存储空间大小，value代表列的真实值





插入记录:

![Xnip2021-12-03_15-06-09](MySQL Note.assets/Xnip2021-12-03_15-06-09.jpg)



因为记录的主键列只有一个id列，所以**只需要在undo日志中存储待插入记录的id列占用的空间长度和真实值即可**

因为这里插入了两台记录，所以**会产生两条类型为TRX_UNDO_INSERT_REC的undo日志**





- 第一条undo日志的undo no为0，记录主键占用的存储空间长度为4，真实值为1，如:

![Xnip2021-12-03_15-12-26](MySQL Note.assets/Xnip2021-12-03_15-12-26.jpg)

- 第二条undo日志的undo no为1，记录主键占用的存储空间长度为4，真实值为2，如:

![Xnip2021-12-03_15-14-41](MySQL Note.assets/Xnip2021-12-03_15-14-41.jpg)





roll_pointer:

- 其本质就是一个指向记录对应的undo日志的指针



我们之前插入的两条记录，意味着向聚簇索引和二级索引插入了2条记录

聚簇索引记录存放在类型为FIL_PAGE_INDEX的页面中，undo日志存放在类型为FIL_PAGE_UNDO_LOG的页面中，效果为:

![Xnip2021-12-03_15-21-50](MySQL Note.assets/Xnip2021-12-03_15-21-50.jpg)

- roll pointer指向记录对应的undo日志















### 20.3.2 DELETE操作对应的undo日志



回顾:

插入的记录会根据记录头信息中的next_record属性组成一个单向链表，该链表称为正常记录链表

被删除的记录也会根据next_record属性组成一个链表，只不过**该链表的记录占用的空间可以重用**，该链表**称为垃圾链表**。Page Header部分中有一个名为PAGE FREE的属性，其指向垃圾链表的头节点



Eg:

![Xnip2021-12-06_13-40-31](MySQL Note.assets/Xnip2021-12-06_13-40-31.jpg)



- 在垃圾链表中，这些记录所占的空间可以被重用
- PAGE_FREE代表该垃圾链表的头节点



如果使用DELETE语句将正常记录中的最后一条删除，则需要经历两个过程:

- **仅仅将deleted_flay属性设置为1，该阶段称为delete mark**

Eg:

![Xnip2021-12-06_13-45-37](MySQL Note.assets/Xnip2021-12-06_13-45-37.jpg)

- 此时最后一条记录的delete_flag被设置为了1，但该记录还没有加入到垃圾链表中
- 所以此时该记录既不是正常记录，也不是已删除记录，而是处于中间状态的记录



注：在删除语句所在的事务提交之前，被删除的记录会一直处于这种中间状态






































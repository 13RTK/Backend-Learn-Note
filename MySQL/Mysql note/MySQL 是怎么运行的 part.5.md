# 二十、undo日志



## 20.1 事务回滚的需求

- Server, OS错误
- 手动rollback



回滚时需要记录的东西:

- 插入记录时，记下记录的主键值，回滚时将主键值对应的记录删除即可
- 删除记录时，记下插入数据的内容，回滚时将这些内容组成记录后插入回原表中即可
- 修改记录时，需要记录下更新列的旧值，回滚时将这些列设置为旧值即可



这些为了回滚而记录的东西称为undo日志









## 20.2 事务id



### 20.2.1 分配事务id的时机



事务可以是一个只读事务，也可以是一个读写事务(默认)



如果事务在执行时对表进行了改动(不含读取)，那么InnoDB会为它分配一个独一无二的事务id。

分配的方式:

- 对于只读事务来说:

之后**只有在它第一次对某个用户创建的临时表执行改动时**，才会分配一个独一无二的事务id



例如:

在使用EXPLAIN分析查询计划的时候，有时会在Extra列看到Using temporary的提示，说明在执行时会用到内部的临时表，在事务回滚时，并不需要将该临时表也回滚，所以也不会为该事务分配事务id





- 对于读写事务来说，只有在其第一次对表CRUD时才会为事务分配一个唯一事务id，否则不会为该事务分配事务id



现在只需要知道:

只有在事务对表进行改动时才会为其分配一个事务id(没有分配时，事务的默认id为0)

























### 20.2.2 事务id的生成

事务id本质为一个数字，分配策略如下:



- 服务器会在内存中维护一个全局变量，每当需要分配事务id时，就将该变量的值作为事务id分配给事务，之后该变量 + 1
- 当该变量的值为256的倍数时，将该值刷新到系统表空间中页号为5的页面中一个名为Max Trx ID的属性中，该属性占用8字节的存储空间
- 重启后，该值会加上256后赋值给之前的全局变量(变量的值可能大于该Max Trx ID的值)

这样就能保证事务id是一个递增的数字了



















### 20.2.3 trx_id隐藏列



之前在行格式中说过，聚簇索引记录除了用户记录外，还会添加名为trx_id、roll_pointer的隐藏列(如果没有主键和不为null的唯一键，还会添加一个row_id列)





其中的trx_id就是**对该聚簇索引记录进行修改的语句所在事务对应的事务id**



















## 20.3 undo日志格式



为了实现原子性，InnoDB在进行实际的CUD之前，会先将对应的undo日志记录下来

一个事务会对应多条undo日志，**这些undo日志从0开始编号，这个编号称为undo no**



这些undo日志被记录到类型为FIL_PAGE_UNDO_LOG的页面中，这些页面从系统表空间中分配，也可以从一个专门存放undo日志的表空间(undo tablespace)中分配





不同的操作都会产生怎样的undo日志呢？

Eg table:

![Xnip2021-12-03_14-52-51](MySQL Note.assets/Xnip2021-12-03_14-52-51.jpg)

- 记住table_id

















### 20.3.1 INSERT操作对应的undo日志



在插入记录时，最终的结果都是将该记录插入到数据页中，在写对应undo日志时，只需要将该记录的主键值记录好就行了



该undo日志的类型为TRX_UNDO_INSERT_REC，完整结构为:

![Xnip2021-12-03_15-01-14](MySQL Note.assets/Xnip2021-12-03_15-01-14.jpg)



- undo no在事务是从0开始递增的。只要事务没有提交，**每生成一条undo日志，该日志的undo no自增**
- 如果**记录的主键只含一列**，该上述类型的undo日志中，只需要将列占用存储空间大小和真实值记录下来即可

**如果包含多个列，则需要将每个列的存储空间和真实值都记录下来**，len表示列占用的存储空间大小，value代表列的真实值





插入记录:

![Xnip2021-12-03_15-06-09](MySQL Note.assets/Xnip2021-12-03_15-06-09.jpg)



因为记录的主键列只有一个id列，所以**只需要在undo日志中存储待插入记录的id列占用的空间长度和真实值即可**

因为这里插入了两台记录，所以**会产生两条类型为TRX_UNDO_INSERT_REC的undo日志**





- 第一条undo日志的undo no为0，记录主键占用的存储空间长度为4，真实值为1，如:

![Xnip2021-12-03_15-12-26](MySQL Note.assets/Xnip2021-12-03_15-12-26.jpg)

- 第二条undo日志的undo no为1，记录主键占用的存储空间长度为4，真实值为2，如:

![Xnip2021-12-03_15-14-41](MySQL Note.assets/Xnip2021-12-03_15-14-41.jpg)





roll_pointer:

- 其本质就是一个指向记录对应的undo日志的指针



我们之前插入的两条记录，意味着向聚簇索引和二级索引插入了2条记录

聚簇索引记录存放在类型为FIL_PAGE_INDEX的页面中，undo日志存放在类型为FIL_PAGE_UNDO_LOG的页面中，效果为:

![Xnip2021-12-03_15-21-50](MySQL Note.assets/Xnip2021-12-03_15-21-50.jpg)

- roll pointer指向记录对应的undo日志















### 20.3.2 DELETE操作对应的undo日志



回顾:

插入的记录会根据记录头信息中的next_record属性组成一个单向链表，该链表称为正常记录链表

被删除的记录也会根据next_record属性组成一个链表，只不过**该链表的记录占用的空间可以重用**，该链表**称为垃圾链表**。Page Header部分中有一个名为PAGE FREE的属性，其指向垃圾链表的头节点



Eg:

![Xnip2021-12-06_13-40-31](MySQL Note.assets/Xnip2021-12-06_13-40-31.jpg)



- 在垃圾链表中，这些记录所占的空间可以被重用
- PAGE_FREE代表该垃圾链表的头节点



如果使用DELETE语句将正常记录中的最后一条删除，则需要经历两个过程:







#### 阶段1

- **仅仅将deleted_flay属性设置为1，该阶段称为delete mark**

Eg:

![Xnip2021-12-06_13-45-37](MySQL Note.assets/Xnip2021-12-06_13-45-37.jpg)

- 此时最后一条记录的delete_flag被设置为了1，但该记录还没有加入到垃圾链表中
- 所以此时该记录既不是正常记录，也不是已删除记录，而是处于中间状态的记录



注：在删除语句所在的事务提交之前，被删除的记录会一直处于这种中间状态



















#### 阶段2

- **当该删除语句所在事务提交后**，**会有专门的线程将记录删除掉**，此时就是真正的删除
- 会**将记录从正常记录链表中移除，并加入到垃圾链表中**，还会调整一些页面信息



- **该阶段称为purge**







阶段2执行完后，这条记录才算是真正地被删除了，其所占用的存储空间就可以被重用了

Eg:

![Xnip2021-12-06_13-57-11](MySQL Note.assets/Xnip2021-12-06_13-57-11.jpg)

- 在将删除记录添加到垃圾链表中时，实际时间该记录添加到了链表的头节点处，还会修改PAGE_FREE属性的值





补充:

每当有记录加入到垃圾链表后，都会将PAGE_CARBAGE属性的值加上已删除占用记录占用的存储空间大小



PAGE_FREE指向垃圾链表的头节点，每当新插入记录时，会首先判断垃圾链表头节点指向的已删除记录存储的空间是否足够容纳新插入的记录

如果无法容纳，则会申请一个新的空间来容纳这条新记录

如果可以容纳，则会直接重用头节点对应的已删除记录的存储空间，并将PAGE_FREE指向下一个节点



出现的问题:

- 如果头节点指向的记录对应空间大于插入记录所需的空间，那么**重用后会有一部分空间用不到，这部分空间就算作碎片空间**
- 插入纪录越来越多之后，产生的碎片空间也会越来越多，**这些碎片空间如何处置？**

其实不然

- 这些碎片空间占用的存储空间大小会被统计到PAGE_GARBAGE属性中，当一个页面快占满时:
- 此时页面中剩余空间不能分配出给一条完整记录的空间，此时就会先看PAGE_GARBAGE的空间和页面剩余空间相加后，是否可以容纳这条记录
- 如果可以，那么InnoDB会尝试重新组织页面中的记录:
- 该过程就是**开辟出一个临时页，将原页面中的记录依次插入**(依次插入时不会产生碎片)，之后**再将临时页中的内容复制回页面中，这样就能解放碎片空间了**。
- 重新组织比较耗费性能



















从上述可知，在执行删除时，该删除语句所在事务未提交之前，只会经历阶段1(delete mark)

一旦事务提交后，我们就不需要再回滚这个事务了



对应的，undo日志只需要考虑对删除操作在阶段1所做的修改进行回滚即可

因此设计了一个名为TRX_UNDO_DEL_MARK_REC类型的undo日志

Eg:

![Xnip2021-12-06_14-23-20](MySQL Note.assets/Xnip2021-12-06_14-23-20.jpg)



需要注意的点:

- 对一条记录进行delete mark操作前

需要把该记录的trx_id和roll_pointer隐藏列的旧值记录到对应undo日志中的trx_id和roll_pointer属性中

这样做的好处: 可以**通过undo日志的roll_pointer属性**，**找到上一次对该记录进行改动时产生的undo日志**

Eg:

先插入再删除

![Xnip2021-12-06_14-28-58](MySQL Note.assets/Xnip2021-12-06_14-28-58.jpg)

在执行完delete mark之后，中间状态记录、delete mark操作产生的undo日志和INSERT产生的undo日志串成了一个链表，该链表称为版本链(在UPDATE对应的undo日志中会起作用)











- 与插入类型TRX_UNDO_INSERT_REC的undo日志不同

类型为TRX_UNDO_DEL_MARK_REC的undo日志**会多一个与索引列信息的内容**。

如果某列中包含某个索引时，那么**相关信息应该记录到这个索引列各列信息**部分

包含该列在记录中的位置(pos)、该列占用的存储空间大小(len)、该列实际值(value)，所以该部分存储的内容本质上是一个<pos, len, value>的列表。

该部分在事务提交后，**用来对中间状态的记录进行真正的删除**(purge阶段)







例子:

![Xnip2021-12-06_14-44-29](MySQL Note.assets/Xnip2021-12-06_14-44-29.jpg)



删除语句的delete mark操作对应的undo日志结构如图:

![Xnip2021-12-06_14-46-35](MySQL Note.assets/Xnip2021-12-06_14-46-35.jpg)

- 这条delete mark操作对应的undo日志是第三条undo日志，其对应的undo no为2
- 在对记录执行delete mark操作时，记录的trx_id隐藏列的值为100，与当前事务id相同(说明该记录最近一次的修改就在本事务中)，所以将100填入undo日志的trx_id属性中
- 之后将记录的roll_pointer隐藏列的值取出来，填入undo日志的roll_pointer，这样可以**通过undo日志的roll_pointer找到上一次对该记录进行改动时产生的undo日志**
- 由于undo_demo表中有两个索引，所以只要是包含在索引中的列，都需要将列在记录中的位置(pos)，占用的存储空间(len)，实际值(value)存储在undo日志中



- 在索引列中存储的信息:

![Xnip2021-12-06_15-02-57](MySQL Note.assets/Xnip2021-12-06_15-02-57.jpg)



![Xnip2021-12-06_15-03-07](MySQL Note.assets/Xnip2021-12-06_15-03-07.jpg)























### 20.3.3 UPDATE操作对应的undo日志

执行UPDATE时，InnoDB对更新主键和不更新主键有不同的处理方案













#### 1) 不更新主键

不更新主键中，可以细分为**被更新的列占用的存储空间不变化和变化**两种情况





##### (1) 就地更新



**如果更新后的列与更新的列占用空间相同**，则**可以进行就地更新**

此时直接在原记录的基础上修改对应列的值即可



**注意：**必须每个列在更新前后的存储空间都一样大时，才能使用就地更新，否则就不能就地更新











##### (2) 先删旧记录，再插入新纪录



不更新主键时，如果有任何一个被更新列更新前后所占的存储空间大小不一致

那么就需要**先将旧记录从聚簇索引中删除**，然后**根据更新后列的值创建一条新纪录并插入**



这里的删除指的是真正的删除，不是delete mark，也就是将该记录添加到垃圾链表的头节点中

**注意：**与purge不同的是，这里执行删除的线程不是在purge操作中的专门线程，而是由用户线程同步执行真正的删除操作

在删除后，就根据更新的值创建一条新记录，并插入到页面中



如果创建的新纪录所占空间不超过旧记录占用的空间，那么直接重用旧记录所占空间即可，否则需要申请新的空间，如果页面没有足够空间则需要进行页分裂，然后插入新纪录









针对不更新主键的UPDATE操作，对应的undo日志类型为TRX_UNDO_UPD_EXIST_REC

结构如图:

![Xnip2021-12-06_15-27-27](MySQL Note.assets/Xnip2021-12-06_15-27-27.jpg)

该日志需要注意的点

- 

- n_updated属性:

表示UPDATE更新的列数

- 如果UPDATE中更新的列包含索引列，那么都会添加"索引各列信息"这个部分，否则不会添加该部分













如果UPDATE语句更新的列大小没有改变，可以使用就地更新

此时会在改动页面之前记录一条类型为TRX_UNDO_UPD_EXIST_REC的undo日志

如图:

![Xnip2021-12-06_15-36-59](MySQL Note.assets/Xnip2021-12-06_15-36-59.jpg)

注意点:

- 该条记录是id为100的事务产生的第4条undo日志，所以它对应undo no为3
- 该条日志roll_pointer指向undo no为1的日志，也就是插入主键值为2的记录时产生的undo日志，即上一次对记录做出改动时产生的undo日志















#### 2) 更新主键

因为聚簇索引中记录按照主键的顺序串成了一个单向链表，所以如果更新了主键值，该记录在聚簇索引中对应的位置会发生改变

针对更新记录主键值的情况，InnoDB聚簇索引分为了两步







##### (1) 将旧记录进行delete mark



在UPDATE语句对应事务提交之前，只对旧记录执行一次delete mark操作

在事务提交后才执行purge操作，从而将其添加到垃圾链表中(前面是真正的删除)



补充:

之所以只执行delete mark，是因为对应的记录又可能被其他事务访问，如果直接删除则其他事务无法访问，该功能为MVCC(下一章)









##### (2) 根据更新的值创建新纪录，之后将其插入到聚簇索引中去



由于主键值发生了改变，所以需要重新从聚簇索引中定位新纪录所在的位置后，再插入



针对更新主键值的情况:

- 对记录进行delete mark操作时，会记录一条类型为TRX_UNDO_DEL_MARK_REC的undo日志
- 插入记录时，会记录一条类型为TRX_UNDO_INSERT_REC的undo日志



综上，每对一条记录的主键值进行修改时，都为记录两条undo日志























### 20.3.4 增删改操作对二级索引的影响



对二级索引执行INSERT和DELETE操作，与在聚簇索引中执行产生的影响差不多

但UPDATE略微不同

- 如果UPDATE语句中没有二级索引列

Eg:

```mysql
UPDATE undo_demo SET col = '手枪' WHERE id = 2
```

这**不需要对二级索引执行任何操作**



- 如果有

Eg:

```mysql
UPDATE undo_demo SET key1 = 'P92', col = '手枪' WHERE id = 2;
```

此时更新了二级索引的键值，则需要进行两个操作:



- 对旧的二级索引记录执行delete mark操作
- 根据新纪录的值创建一条新的二级索引记录，将其定位到二级索引中对应的位置插入





拓展：

只有聚簇索引中才有trx_id、roll_pointer等属性

但当我们增删改一条二级索引时，都会影响到该条索引所在页的Page Header部分中一个名为PAGE_MAX_TRX_ID的属性，该属性代表当前页的最大事务id(后面会用到该属性)





























## 20.4 通用链表结构

undo日志会被写在什么地方？写入过程中需要注意的问题？



在写入undo日志时，会用到多个链表，这些链表节点都有相同的结构:

![Xnip2021-12-06_16-33-52](MySQL Note.assets/Xnip2021-12-06_16-33-52.jpg)







- List Length: 

表明链表的节点数

- First Node Page Number和First Node Offset的组合

指向链表头节点的指针

- Last Node Page Number和Last Node Offset的组合

指向链表尾节点的指针

整个链表的基节点占用16字节空间







链表基节点和链表节点两个结构组成链表表示图:

![Xnip2021-12-06_16-41-37](MySQL Note.assets/Xnip2021-12-06_16-41-37.jpg)



















## 20.5 FIL_PAGE_UNDO_LOG页面



存储undo日志的页面类型名为FIL_PAGE_UNDO_LOG

其通用页面结构为:

![Xnip2021-12-06_16-44-50](MySQL Note.assets/Xnip2021-12-06_16-44-50.jpg)

其中的Undo Page Header是undo页面特有的，其结构如下:



![Xnip2021-12-06_16-47-20](MySQL Note.assets/Xnip2021-12-06_16-47-20.jpg)

各个属性的意思:

- TRX_UNDO_PAGE_TYPE

本页面准备存储undo日志的类型，其有两个类型：



1. TRX_UNDO_INSERT:

类型为TRX_UNDO_INSERT_REC的undo日志属于这个类，一般由INSERT语句产生(UPDATE语句更新主键时也会产生该类型的undo日志)。

我们将属于该大类的undo日志简称为insert undo日志



2. TRX_UNDO_UPDATE:

除了类型为TRX_UNDO_INSERT_REC的undo日志，其他undo日志都属于这个大类

一般由DELETE、UPDATE语句产生，我们将属于这个da类的undo日志称为update undo日志





**注意: **不同大类的undo日志不能混合存储



拓展: 之所以分为两类，因为其中的insert类型在事务提交后可以直接删除，而update类型需要为MVCC服务







- TRX_UNDO_PAGE_START

表示当前页面从什么位置存储undo日志/表示第一条undo日志在页面中的起始偏移量

- TRX_UNDO_PAGE_FREE

与上面的start对应，表示当前页中存储的最后一条undo日志结束时的偏移量位置。从该位置开始可以继续写新的undo日志了

Eg:

![Xnip2021-12-06_17-00-11](MySQL Note.assets/Xnip2021-12-06_17-00-11.jpg)











